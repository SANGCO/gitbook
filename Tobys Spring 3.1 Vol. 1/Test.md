

## 2.1 UserDaoTest 다시 보기



### 2.1.1 테스트의 유용성



### 2.1.2 UserDaoTest의 특징



#### 웹을 통한 DAO 테스트 방법의 문제점



#### 작은 단위의 테스트

- 개발 테스트, 프로그래머 테스트
  - 단위 테스트는 주로 개발자가 만든 코드를 스스로 확인하기 위해 사용



#### 자동수행 테스트 코드



#### 지속적인 개선과 점진적인 개발을 위한 테스트

- 테스트를 이용하면 새로운 기능이 기대한 대로 동작하는지 확인할 수 있다.
  - 뿐만 아니라 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않는지도 확인할 수도 있다.



### 2.1.3 UserDaoTest의 문제점

- 수동 확인 작업의 번거로움
- 실행 작업의 번거로움



## 2.2 UserDaoTest 개선



### 2.2.1 테스트 검증의 자동화

- 켄트 백 "테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"



### 2.2.2 테스트의 효율적인 수행과 결과 관리



#### JUnit 테스트로 전환



#### 테스트 메소드 전환



#### 검증 코드 전환



#### JUnit 테스트 실행



## 2.3 개발자를 위한 테스팅 프레임워크 JUnit



### 2.3.1 JUnit 테스트 실행 방법



#### IDE



#### 빌드 툴



### 2.3.2 테스트 결과의 일관성



#### deleteAll()의 getCount() 추가



#### deleteAll()과 getCount()의 테스트



#### 동일한 결과를 보장하는 테스트



### 2.3.3 포괄적인 테스트



#### getCount() 테스트



#### addAndGet() 테스트 보완



#### get() 예외조건에 대한 테스트



#### 테스트를 성공시키기 위한 코드의 수정



#### 포괄적인 테스트

- 스프링의 창시자 로드 존슨 "항상 네거티브 테스트를 먼저 만들라"
  - 개발자는 빨리 테스트를 만들어 성공하는 것을 보고 다음 기능으로 나아가고 싶어한다.
    - 긍정적인 경우를 골라서 성공할 만한 테스트를 먼저 작성하게 되기가 쉽다.



### 2.3.4 테스트가 이끄는 개발



#### 기능설계를 위한 테스트



#### 테스트 주도 개발

- 테스트 주도 개발(TDD, Test Driven Development)
  - TDD는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다.
  - TDD의 기본 원칙
    - "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"
    - 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.
- 테스트 없이 오랜 시간 동안 코드를 만들고 나서 테스트를 하면, 오류가 발생했을 때 원인을 찾기가 쉽지 않다.
  - 예외는 A라는 곳에서 발생했는데 사실 원인은 Z에 있을 수도 있기 때문이다.
  - 진작 간단한 테스트를 해봤으면 미리미리 쉽게 발견할 수 있었던 사소한 문제도, 나중에 많은 코드와 얽혀서 돌아가는 상황에서는 쉽게  찾지 못하는 경우가 많다.

- 테스트를 만들고 자주 실행하면 개발이 지연되지 않을까?
  - 테스트 코드 짜는거 생각보다 시간 많이 걸리지 않는다.
  - 테스트 덕분에 오류를 빨리 잡아낼 수 있어서 전체적인 개발 속도는 오히려 빨라진다.



### 2.3.5 테스트 코드 개선



#### @Before



#### 픽스처

- 테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다.
  - 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 `@Before` 메소드를 이용해 생성해두면 편리하다.



## 2.4 스프링 테스트 적용



### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리



#### 스프링 테스트 컨텍스트 프레임워크 적용

- `@RunWith`는 `JUnit` 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다.
  - `SpringJUnit4ClassRunner`라는 `JUnit`용 테스트 컨텍스트 프레임워크 확장 클래스를 지정
    - 그러면 `JUnit`이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.



#### 테스트 메소드의 컨텍스트 공유

- 스프링의 `JUnit` 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만든다.
  - 그리고 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해준다.



#### 테스트 클래스의 컨텍스트 공유

- 스프링 테스트 컨텍스트 프레임워크의 기능은 하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아니다.
  - 여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.
    - 덕분에 테스트 성능이 대폭 향상된다.
    - 스프링은 설정파일의 종류만큼 애플리케이션 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트에서는 이를 공유하게 해준다.



#### @Autowired

- `@Autowired`가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.
  - 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.
  - 일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능하다.
  - 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데, 이런 방법을 타입에 의한 자동와이어링이라고 한다.

- 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다.
  - 따라서 애플리케이션 컨텍스트에는 `ApplicationContext` 타입의 빈이 존재하는 셈이고 DI도 가능하다.

- `@Autowired`는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다.
  - 따라서 SimpleDriverDataSource 클래스 타입은 물론이고, 인터페이스인 DataSource 타입으로 변수를 선언해도 된다.
    - 단, `@Autowired`는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.
- SimpleDriverDataSource 타입의 변수로 선언하는 방법과 DataSource 타입으로 선언하는 방법 중 어떤 것이 나을까?
  - 테스트에서 빈을 어떤 용도로 사용하느냐에 따라 다르다.
    - DataSource에 정의된 메소드를 테스트에서 사용하고 싶은 경우라면 DataSource 타입으로 받는게 좋다.
      - DataSource로 선언해두면 dataSource 빈의 구현 클래스를 변경하더라도 테스트 코드를 수정할 필요가 없다.
    -  SimpleDriverDataSource라는 타입의 오브젝트 자체에 관심이 있는 경우에는 SimpleDriverDataSource 타입으로 선언해야 한다.
  - 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.



### 2.4.2 DI와 테스트

- 인터페이스를 두고 DI를 적용해야 하는 이유
  - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.
  - 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.
  - 테스트
    - 단지 효율적인 테스트를 손쉽게 만들기 위해서라도 DI를 적용해야 한다.
    - DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 한다.



#### 테스트 코드에 의한 DI

- `@DirtiesContext`
  - 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.
  - 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다.
  - 테스트 메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해준다.
    - 매번 애플리케이션 컨텍스트를 만든다는 건 좀 그렇다.
    - 메소드 레벨에도 사용할 수 있다.



#### 테스트를 위한 별도의 DI 설정

- `@ContextConfiguration(locations="/test-applicationContext.xml")`



#### 컨테이너 없는 DI 테스트

- 리스트 2-23 참고
  - `@Before`에서 필요한거 new로 생성해주고 있다.



#### DI를 이용한 테스트 방법 선택

- DI를 테스트에 이용하는 세 가지 방법 중 어떤 것을 선택해야 할까?
  - 세 가지 방법 모두 장단점이 있고 상황에 따라 유용하게 쓸 수 있다.
- 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자.
  - 이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다.
  - 테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려해야 한다.
- 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우가 있다.
  - 이때는 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다.
- 테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정파일을 따로 만들어 사용하는 편이 좋다.
- 테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다. 
  - 이때는 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다.
    - 테스트 메소드나 클래스에 `@DirtiesContext` 애노테이션을 붙이는 것을 잊지 말자고.







## 2.5 학습 테스트로 배우는 스프링

- 일반적으로 애플리케이션 개발자는 자신이 만들고 있는 코드에 대한 테스트만 작성하면 된다.
  - 하지만 때로는 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다.
    - 이런 테스트를 **학습 테스트**(learning test)라고 한다.
- 학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다.
  - 기술이나 기능에 대한 검증이 아니라 API를 제대로 이해하고 사용 방법을 바로 알고 있는지를 검증하려는 게 목적이다.



### 2.5.1 학습 테스트의 장점

- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다. 
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
- 테스트 작성에 대한 좋은 훈련이 된다.
- 새로운 기술을 공부하는 과정이 즐거워진다.



### 2.5.2 학습 테스트 예제



#### JUnit 테스트 오브젝트 테스트

- JUnit이 매번 새로운 테스트 오브젝트를 만든다는 실을 분명히 확인할 수 있는 학습 테스트를 만들었다.
  - 리스트 2-25 참고



#### 스프링 테스트 컨텍스트 테스트

- 스프링의 테스트용 애플리케이션 컨텍스트는 테스트 개수에 상관없이 한 개만 만들어지고 모든 테스트에서 공듀된다는 것을 검증하는 학습 테스트를 만들었다.
  - 리스트 2-27

- 1장부터 지금까지 설명한 내용 중에서 어떤 것을 학습 테스트로 만들어볼 수 있을까?
  - 스프링이 싱글톤 방식으로 빈의 오브젝트를 만든다는 것을 검증해보는 테스트
  - 테스트 컨텍스트를 이용한 테스트에서 `@Autowired`로 가져온 빈 오브젝트가 애플리케이션 컨텍스트에서 직접 getBean()으로 가져오는 것과 동일한지 확인하는 테스트
  - XML에서 스트링 타입의 프로터티 값을 설정한 것이 정말 빈에 잘 주입되는지 확인하는 테스트



### 2.5.3 버그 테스트

- 버그 테스트(bug test)란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.
  - QA팀이 기능 오류를 발견 하거나, 사용자가 버그가 있다고 알려오는 경우 무턱대고 코드를 뒤져가면서 수정하려고 하기보다는 먼저 버그 테스트를 만들어보는 편이 유용하다.
  - 버그 테스트는 일단 실패하도록 만들어야 한다.
    - 버그가 원인이 되서 테스트가 실패하는 코드를 만드는 것이다.
    - 그리고 나서 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다.
    - 테스트가 성공하면 버그는 해결된 것이다.

- 버그 테스트의 필요성과 장점
  - 테스트의 완성도를 높여준다.
    - 기존 테스트에서는 미처 검증하기 못했던 부분이 있기 때문에 오류가 발생한 것이다.
  - 버그의 내용을 명확하게 분석하게 해준다.
    - 버그가 있을 때 그것을 테스트로 만들어서 실패하게 하려면 어떤 이유 때문에 문제가 생겼는지 명확히 알아야 한다.
      - 따라서 버그를 좀 더 효과적으로 분석할 수 있다.
  - 기술적인 문제를 해결하는 데 도움이 된다.
    - 때로는 버그가 있다는 건 알겠지만 그 원인이 무엇인지 정확하게 파악하기 힘들 때가 있다.
      - 아무리 코드와 설정 등을 살펴봐도 별다른 문제가 없는 것 같이 느껴지거나 또는 기술적으로 다루기 힘든 버그를 발견하는 경우도 있다.
      - 이럴 땐 **동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트**를 만들어보면 도움이 된다.
      - 또한 외부의 전문가나 포럼, 메일링 리스트 등 커뮤니티의 도움을 받을 때도 도움이 된다.



## 2.6 정리

