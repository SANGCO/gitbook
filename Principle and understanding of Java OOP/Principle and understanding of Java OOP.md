

## 1장. 사람을 사랑한 기술

- 기계어(바이너리 코드) vs 어셈블리어 vs C언어(컴파일러) vs 자바(JVM)
  - C언어 한번 코딩하고 컴파일러만 운영체제에 맞는걸로 바꾸면 된다고? (반은 맞고 반은 틀리다.)	
    - C언어로 작성한 코드에 운영체제에서 지원하는 부분을 사용하면 당연히 운영체제 별로 달라 진다.	
    - 운영체제에서 지원하는 코드가 없는 C언어 코드라면 운영체제별 컴파일만 바꾸면 돌아갈 수 있다.

- 순서도(전체흐름), NS차트(나시 슈나이더만 다이어그램, 메소드 흐름)

- 다인패턴은 객체지향 베스트 프렉티스라고 생각해보자.

- 엔터프라이즈 에플리케이션을 뭐라고 생각하면 되는건가?

- 스프링은 PSA기법(일관성 있는 추상화)을 통해서 다양한 기술을 표준화된 방식으로 사용



## 02장 자바와 절차적/ 구조적 프로그래밍

- JVM, JRE, JDK	
  - JVM은 가상의 컴퓨터
  - JRE는 (JVM용) OS 실행환경
  - JDK는 (JVM용) 개발도구
  - 운영체제인 JRE가 main이 실행이되면 가상의 컴퓨터인 JVM을 실행시키는 순서다.



- 프로그램이 메모리를 사용하는 방식
  - 코드를 실행하는 영역과 테이터를 저장하는 영역이 나누어져 있다는걸 생각해 보자.
  - 데이터를 저장하는 영역이 스태틱, 스택, 힙으로 나누어져 있는거다.
  - [ { ] 중괄호를 만나면 스택에 영역이 생기고 [ } ] 중괄호가 닫히면 스택에 영역이 사라진다.
  - 스태틱 메소드도 메소드의 이름등 정보는 스태틱에 뜨지만 중괄호를 만나면 스택에 영역이 뜬다.		
    - 여러 객체를 만들고 그 객체들이 스태틱 메소드를 호출을 하면 각각의 객체들이 스택 영역에서 스태틱 메소드를 실행 시킨다.



- 멀티스레드는 스택 영역을 스레드 개수 만큼 만들어서 사용한다고 한다.



- 자바는 call by value 인가 call by reference 인가?
  - int 등과 같은 primitive타입은 매개변수로 넣으면 스택영역에 새로운 공간을 잡는 call by value
  - 인스턴스에 경우 참조 주소값을 던지는 call by reference 방식으로 동작한다.



## 03장: 자바와 객체 지향

- 객체 지향은 인간 지향이다.
  - 객체지향은 기계에 맞춘 사고에서 벗어나 현실세계를 인식하는 방식, 사고하는 방식의 전환이라고



- 객체 지향의 4대 특성 - 캡! 상추다
  - 캡슐화, 상속, 추상화, 다형성



- 클래스 vs. 객체 = 붕어빵틀 vs. 붕어빵 ???
  - 올바른 메타포, 클래스:객체 = 펭귄:뽀로로 = 사람:김연아 (분류(class)와 사물(object)의 관계)
    - 같은 특성의 집합 개념이 클래스이다. 
    - 객체는 유일무이 해야한다.
    - object = class의 instance
    - 하이얼아키가 아니라 벤다이어그램을 떠올리자. 부모자식 관계가 아니라 상위 하위 관계



- 추상화: 모델링
  - 네이밍을 아무렇게나 하는게 아니다. 거기에는 많은 고민들과 의미가 담겨있다. 
  - 객체지향의 추상화는 곧 모델링이다.
    - 추상화란 구체적인걸 분해해서 특정 분야에서 쓰인다고 했을 때 필요한 부분만 재조합 하는 것.
    - 그림에서 추상화란 그림을 사진같이 그리는게 아니라 특징을 부각시켜서 그린 그림을 말한다.
    - 프로그래밍에서 추상화도 실제 사물을 정확하게 복제 하는게 아니라 목적에 맞게 관심있는 특성만을 추출해서 표현하는 것이다.
    - 추상화의 결과물이 모델이고 자바에서는 모델을 클래스로 표현한다.
      - 사람을 예로 들어서 은행(계좌정보, 신용정보 등등) 병원(키, 몸무게, 지병 등등) 같은 사람이라는 분류도 내가 만들고자 하는 애플리케이션이 어디에서 사용되는가에 따라서 추상화로 뽑아내는 특성이 달라지는 거다.



- 상속: 재사용 + 확장
  - inheritance가 아니라 extend라는 용어를 선택한 이유가 있을거다.
  - 김연아(사물) is a kind of 사람(분류)
  - 인터페이스 구현 클래스 is able to 인터페이스
    - 인터페이스를 만들때 네이밍 할때 able to를 떠올려 보자.		
    - 뭔가 공통적으로 할 수 있는 기능을 인터페이스로 빼고 이름을 Serializable(직렬화 할 수 있는), Cloneable(복제할 수 있는) 이런식으로 네이밍 해보자. 
  - 정적 메소드, 클래스 변수를 언제 사용하는가
    - 뽀로로나 핑구나 펭귄 계열은 다 꼬리를 하나 가지고 있다. 
      - 이건 상위에 클래스 변수로 빼서 다같이 쳐다보는게 더 효율적이다.
    - 유틸성 클래스는 객체를 생성하는거 보다 static으로 만드는게 효율적이다.
      - Math 클래스는 static 메소드 천지다.



- 다형성: 사용편의성
  - 오버라이딩, 오버로딩

    - ride 올라타다. 
      - 상위 클래스의 메소드에 올라타다.
    - load 적재하다. 
      - 매개변수를 필요한 만큼 올리는거다.

  - Penguin pororo = new Penguin();	

    Animal pingu = new Penguin();

    - 힙엽역에는 상속관계에 있는 모든 클래스가 다 같이 뜬다. (모든 인스턴스는 Object 클래스도 같이 뜨겠지?)
    - 클래스 타입을 Penguin으로 하면 Penguin을 가리키지만 new Penguin()을 했지만 받는 타입이 Animal 이면 메모리 상에서도 Animal을 가리키고 Penguin에 있는 기능은 쓸 수 없다.



- 캡슐화: 정보 은닉
  - 자바 키워드 (private, protected, [default], public)



## 04장 자바가 확장한 객체 지향

- abstract 클래스 vs. interface
  - 추상 메소드는 abstract 클래스에 있든지 interface에 있든지 간에 자식들에게 구현을 강요한다.
  - abstract 클래스는 자기 안에서 메서드 구현도 가능하지만 이건 인터페이스도 자바8 부터 default 메서드로 가능하다.
  - abstract 클래스는 메서드 구현을 강제하는 점도 있지만 상속구조를 만든다는 특징이 있다.
  - 이펙티브 자바 규칙 18. 추상 클래스 대신 인터페이스를 사용하라
  - 인터페이스가 default 메소드를 가지게된 이유는 이펙티브 자바 규칙 18번 처럼 인터페이스의 사용을 장려하기 위해?
    - 하위호환성을 보장하면서 기능을 추가하기 위해서 나온게 인터페이스의 default 메서드, 사실 꼼수다	
    - 자바의 발목을 잡고 있는 부분이 하위호환성, 새로 나오는 언어들은 하위호환성 측면에서 장점이 있다.
  - abstract는 클래스 상속과 인터페이스의 기능들을 둘다 가진 느낌이다.



- 동일한 타입의 클래스의 인스턴스에 메소드는 static 영역으로 올라간다?
  - JVM은 지능적으로 객체 멤버 메서드 test()를 스태틱 영역에 단 하나만 보유한다.
  - 눈에 보이지는 않지만 test() 메서드를 호출할 때 객체 자기자신을 나타내는 this 객체 참조 변수를 넘긴다.



- 결합도란 모듈(클래스)간의 상호의존 정도
  - 상호의존성이 낮아야 객체의 재사용이나 수정, 유지보수가 용이하다.



- 응집도란 하나의 모듈 내부 구성 요소들의 기능적 관련성
  - 응집도가 높아야 하나에 책임에 집중하고 독립성이 높아져 재사용, 기능의 수정 유지보수가 용이해진다.



## 05장 객체 지향 설계 5원칙 - SOLID

- SRP 단일 책임 원칙: 
  - 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
    - 하나의 클래스는 하나의 일만
  - 남자라는 클래스를 남자친구, 아들, 사원, 소대원 등 여러 개의 클래스로 분리
    - 기능을 상위의 abstract 메소드로 빼고 각각의 클래스는 자신의 일을 하면 if문을 줄일 수 있다.



- OCP 개방 폐쇄 원칙 
  - 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
  - OCP의 좋은 예가 스프링프레임워크, JDBC, log4j



- LSP 리스코프 치환 원칙
  - 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.



- ISP 인터페이스 분리 원칙
  -  클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
  - 남자 클래스를 쪼개는게 아니라 각각의 인터페이스를 중간에 만들어서 클라이언트는 해당하는 인터페이스 하고만 의존 관계를 맺게 



- DIP 의존 역전 원칙
  - 자신보다 변하기 쉬운 것에 의존하지 마라.
  - 자동차가 스노우타이어를 바라보고 있으면 바뀌기 쉬우니 자동차가 타이어를 바라고게 만들고 스노우타이어가 타이어를 보게