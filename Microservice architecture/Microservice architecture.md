

## CHAPTER 01 마이크로서비스 아키텍처의 이해



### 1.1 소프트웨어 아키텍처의 이해



#### 소프트웨어 아키텍처란 무엇인가?



##### 소프트웨어 아키텍처의 정의	

- 소프트웨어를 구성하는 요소와 요소 간의 관계를 정의한 청사진

##### 아키텍처의 표현

- 아키텍처를 표현하는 언어로서 UML과 같은 **표준화 모델링 언어**로 작성하는 것이 바람직하다.
- 아키텍처의 표현은 다양한 관점으로 접근하고 표현되어야 한다.

  - 운영자, 아키텍트, 백엔드 개발자, 화면 개발자, 품질 담당자 등등
- 사용 사례를 충족시키고 표현하기 위한 **아키텍처 관점 네 가지**
  - 논리 뷰
  - 프로세스 뷰
  - 구현 뷰
  - 배치 뷰
- 위 4가지 뷰의 중심에 있는 유스케이스 뷰

  - 유스케이스는 시스템의 사용 사례를 의미
- 주로 **UML, 유스케이스, 시퀀스 다이어그램** 등을 주로 많이 썼던거 같다.

##### 아키텍처의 역할

- 소프트웨어 아키텍처는 건축공학에 비유하면 건축물의 뼈대이고, 도시공학에 비유하면 도시의 전체적인 구조라 할 수 있다.
- 소프트웨어를 구성하는 단위 프로그램의 로직(logic)을 견고히 만드는 것만큼이나 프로그램들을 연결하고 안정적으로 운영하기 위한 전체적인 뼈대를 설계하는 것이 무엇보다 중요하다.



#### 소프트웨어 아키텍처 스타일



##### 스타일이란?

- 아키텍처의 스타일은 **특정 제약 조건**에서 아키텍처의 **방향과 접근 방법**을 말한다.
  - 건축물을 예로 들면 주택, 빌라, 아파트 빌딩 등 여러 가지 건축 스타일이 있다.
    - 아파트만 보아도 주거용 아파트와 상가가 함께 있는 주상복합 아파트 등으로 다양하고, 각각의 건축 방식과 공법도 다를 것이다.



##### 소프트웨어 아키텍처 스타일

- 아키텍처 스타일과 아키텍처 패턴의 차이점
  - **아키텍처 스타일**은 상황을 해결할 수 있는 **접근 방법을 제시**해 주지만, 정답을 제시해 주지는 않는다.
    - 다만, 스타일에서 제시하는 접근 방법을 선택하면 그만큼 실패할 확률을 줄일 수 있다.
  - **아키텍처 패턴**은 시스템이 가지는 문제점이나 해결해야 할 문제의 **구체적인 해결 방안**을 경험적 사례를 기반으로 제시
    - 메시지 전달 어떻게 할까?  →  피어 투 피어 패턴
    - 이벤트 처리를 어떻게 하지?  →  이벤트-버스 패턴



#### 아키텍처와 아키텍트 역할의 변화



##### 모놀리스에서 마이크로서비스로 변화

- **모놀리스한 아키텍처**는 모든 업무 로직이 하나의 애플리케이션 형태로 패키지(package)되어 서비스되고, 애플리케이션에서 사용하는 데이터 또한 한 곳에 모인 데이터를 참조하여 서비스하는 것이 일반적인 형태이다.
- **마이크로서비스**를 간단하게 말하자면, 기존 모놀리스와는 달리 하나의 큰 애플리케이션을 아주 작은 애플리케이션으로 나누어 서비스하자는 사상이다.
- 비즈니스 환경의 급속한 변화와 시스템의 규모와 복잡도의 증가로 모놀리스 형태로 더는 해결할 수 없는 새로운 기술적인 이슈들
  - 마이크로서비스 아키텍처 스타일은 그 이슈들에 대응할 수 있는 아키텍처적인 접근 방법의 하나이다.



##### 회색지대와 아키텍트

- 대내외의 크고 작은 시스템 통합 프로젝트를 수행하다 보면 업무 영역이나 기술적인 측면에서 담당자가 애매하거나 복잡한 이해관계자들의 의견 대립으로 결론 나지 않은 상태 혹은 무관심한 상태로 방치되는 영역이 있다.
  - 항상 문제가 되는 부분은 조직과 조직의 경계이다.
  - 틈이 생기지 않게 영역을 중첩시켜 조직을 구성하면 되지만, 그 또한 쉽지 않다.
- 기술적인 측면에서 팀 간의 틈을 메워 주는 역할자는 아키텍트 집단이다.
  - 결과물의 통합과 프로젝트 경계 밖의 요소와 연결하는 역할을 잘 수행하여 프로젝트를 성공적으로 이끄는 것이 이들 집단의 역할



##### 아키텍트 역할의 세분화와 변화

- 최근의 기술 발전 속도와 오픈소스의 발전 및 확장 속도를 보면 특정한 사람이 모든 영역의 기술에 정통할 수는 없다.
  - 아키텍트가 수행해야 할 역할에 대해서 보다 전문성을 가지기 위해 분류할 필요가 있다.
    - 하드웨어 구성 → 테크니컬 아키텍트
    - 네트워크 구성 → 인프라 아키텍트
    - 데이터 구성 → 데이터 아키텍트
    - 프레임워크 구축 → 프레임워크 아키텍트
    - 화면기술 구성 → 프론트엔드 아키텍트
    - 소프트웨어 구성 → 소프트웨어 아키텍트
- 최근 클라우드 플랫폼의 발전으로 아키텍트의 역할이 어디까지인지 모호해지는 경향도 있다.
  - 대부분의 정형화된 기능은 플랫폼에서 자동화로 제공하고 있다.



##### 솔루션 아키텍트

- 세계적인 플랫폼 사업자들이 과거에 아키텍트들이 했던 대부분의 작업을 SaaS(Software as a Service), Paas(Platform as a Service), IaaS(Infra as a Service) 등 자동화된 기능으로 지원한다.

  - 시스템 자원 구성, 할당, 관리, 모니터링, 소프트웨어 빌드, 통합, 배포 등 일련의 프로세스들을 몇 번의 버튼 클릭만으로도 자동화, 시각화하여 플랫폼 기반의 서비스로 제공하고 있다.
  - 서비스 내에 기능 단위까지도 SaaS형 서비스로 제공하기 시작하였다.
  - 비즈니스 서비스 기업들은 인증 권한, 로깅, 모니터링 서비스에서 AI, 블록체인, 빅데이터 서비스 등 전문 기술이 필요한 영역까지 단 몇 분 만에 원하는 서비스를 만들 수 있고, 필요한 만큼만 사용하고 비용을 지급하면 되는 비즈니스 시스템 생태계를 조성함.

- **SaaS**(**Software** as a Service)

  - 사용자는 인터넷을 통해 클라우드 기반 앱에 연결하여 이를 사용할 수 있다.

  - 웹 기반 메일 서비스, 깃헙, 지라 등

  - [SaaS란?](https://azure.microsoft.com/ko-kr/overview/what-is-saas/)

- **Paas**(**Platform** as a Service)

  - 단순한 클라우드 기반 앱에서 정교한 클라우드 사용 엔터프라이즈 응용 프로그램에 이르기까지 

    모든 것을 제공할 수 있는 리소스가 포함되어 있으며 클라우드에서 제공되는 완전한 개발 및 배포 환경

  - 요즘 AWS나 Azure에 배포 뿐만 아니라 개발툴도 지원해준다고 하던데

  - [PaaS란?](https://azure.microsoft.com/ko-kr/overview/what-is-paas/)

- **IaaS**(**Infra** as a Service)

  - 인터넷을 통해 프로비저닝 및 관리되는 인스턴트 컴퓨팅 인프라이다.

  - [IaaS란?](https://azure.microsoft.com/ko-kr/overview/what-is-iaas/)

- 새로운 솔루션들을 보다 빨리 습득하고 조합하여 효율적인 솔루션을 제시하는 것이 현명한 아키텍트의 역할

<img src="../../study/정리/책 정리/자바 기반의 마이크로서비스 이해와 아키텍처 구축하기.assets/image-20200807161358579.png" alt="image-20200807161358579" style="zoom:50%;" />



### 1.2 마이크로서비스 아키텍처



#### 마이크로서비스 아키텍처의 이해



##### 마이크로서비스 아키텍처의 개념

- 아주 작은 단위의 서비스들을 실행할 수 있도록 구성하기 위한 서비스 중심의 아키텍처



##### 모놀리스 아키텍처와의 차이점

- 모놀리스 아키텍처와 차이점은 하나의 애플리케이션 형태가 아닌 **분할된 다수의 서비스**라는 점
- 애플리케이션 기능뿐만 아니라 **데이터까지 분리**하여 격리된 독립된 환경으로 구성되는 것이 가장 큰 차이점
- 마이크로서비스 아키텍처 구조는 서비스의 수평적 확장에 유연성과 탄력성을 높여 성능적 이슈에 대해서 유연하게 대처할 수 있는 구조를 가진다.



#### 서비스지향 아키텍처



##### 서비스지향

- **서비스지향 아키텍처(SOA)**는 대규모 시스템 환경에서 업무 처리 단위를 각각의 서비스로 반영하여 **데이터 중심이 아닌** 전체 시스템을 **서비스 중심으로** 설계하는 아키텍처 스타일
- 서비스지향 아키텍처의 몇 가지 특징
  - 서비스 계약
    - 그림 1.13 참고
  - 서비스의 가용성
    - 그림 1.14 참고
  - 서비스 권한
  - 트랜잭션
    - 그림 1.16 참고
    - **BASE**(Basically Available Soft State Eventual Consistency) 트랜잭션
      - 클라우드의 핵심 개념
      - 'basically available'
        - 낙관적 잠김(optimistic locking)과 큐(queue)
      - 'soft state'
        - 외부 전달 데이터로 인해서 상태가 갱신되는 것
          - 두 개의 노드가 있으면 한쪽에서 전달된 데이터로 인해 다른 한쪽의 노드가 갱신된다는 사상
      - 'eventual consistency'
        - 두 노드의 데이터가 일시적으로 불일치한 시점이 있고 일관성이 없는 상태이지만, 결국에는 두 노드의 데이터가 같아진다는 개념
  - 서비스 관리
    - 그림 1.17 참고



##### SOA와 마이크로서비스 아키텍처는 무엇이 다른가?

- **SOA(Service Oriented Architecture)**
- 공통점
  - 소프트웨어를 설계할 때 서비스 중심의 설계를 지향한다는 점
- 차이점
  - SOA는 **통합**과 **공유**, 마이크로서비스 아키텍처는 **분산**과 **독립**이라는 개념으로 구분할 수 있다.
  - 마이크로서비스 아키텍처에서 서비스는 작고 한 가지 일에 집중하는 반면, SOA 서비스는 비즈니스에 집중한다.
  - 서비스 오너십 측면에서 마이크로서비스는 **하나의 작은 팀에서 관리**한다.
  - 서비스 공유 정도의 차이
    - 마이크로서비스는 서비스 공유의 최소화를 지향하는 반면, SOA는 되도록 많은 서비스의 공유를 지향한다.
    - 마이크로서비스 아키텍처는 **서비스 간의 결합도를 낮추어** 변화에 능동적으로 대응하기 위한 **민첩성에 초점**을 두지만, SOA는 **재사용**을 높여 **비용을 절감**하고 **품질**을 높이는 데 초점을 둔다.
  - 기술 방식의 차이
    - SOA가 공통의 서비스를 ESB(Enterprise Service Bus)라는 공통된 채널에 모아 사업 측면에서 공통 서비스 형식으로 서비스를 제공하였다면, 마이크로서비스는 각각의 독립된 서비스가 필요에 따라 노출된 REST API를 사용한다.



#### 왜 마이크로서비스 아키텍처인가?



##### 민첩한 서비스

- 서비스를 기획하고 만들어서 즉각적으로 시장에 선보일 수 있다면 기업의 생산적인 활동을 위한 여러 시도가 훨씬 효율적이고 빠르게 진행될 수 있다.
  - 서비스 단위를 아주 작게 만들어서 즉시 개발 배포



##### 유연한 인프라

- 서비스 개발에서 배포, 운영까지 서비스의 확장이 자유롭고 관리가 쉬운 자동화된 인프라



##### Happy Path

- 마이크로서비스 아키텍처는 작은 서비스라는 점에서 필요한 서비스를 빠르게 개발하고 먼저 검증해 볼 수 있다.
  - Happy Path는 서비스의 기본적인 사상을 실체화하기 위한 최소한의 작업 경로를 뜻한다.
    - 서비스 요건의 핵심적인 기능 중 최소 기능만을 도출하여 사용 사례를 기반으로 시나리오를 서비스로 만들어서 방향성 설정과 결과를 사전에 체감할 수 있게 하는 작업
    - 서비스가 만들어지기까지 여러 단계 중 예외 상황을 제외한 정상적인 요건과 상황에서 핵심이 되는 최소한의 기능만 개발하여 서비스를 완성
      - 그림 1.23 참고



## CHAPTER 02 클라우드 네이티브의 이해



### 2.1 클라우드 네이티브

클라우드 네이티브(cloud native)는 클라우드 환경에 친화적인 애플리케이션(application), 아키텍처(architecture), 인프라(infrastructure) 등의 환경을 뜻한다.



#### 클라우드 네이티브 애플리케이션

클라우드 네이티브 애플리케이션 비즈니스 환경 변화에 민첩하고 능동적으로 대응하기 위해 클라우드 네이티브 환경에서 SaaS(Software as a Service)나 FaaS(Function as a Service) 형태로 서비스되는 애플리케이션을 의미한다.



##### 마이크로서비스

- 마이크로서비스는 아주 작은 서비스이며, 클라우드 환경에 잘 맞는 서비스이다.



##### SaaS

- 소프트웨어가 필요할 때 즉시 필요한 만큼만 사용할 수 있는 서비스 형태
- 위에서 정리 했음.



##### 12팩터

- 12팩터(Factor)는 SaaS가 가져야 할 클라우드 네이티브 특성과 지켜야 할 패턴들에 대한 경험적인 내용을 잘 정리해 두고 있다.
  - 코드베이스 / 종속성 / 환경 설정 / 백엔드 서비스 / 빌드, 릴리스 및 실행 / 프로세스 / 포트 바인딩 / 동시성(concurrency) / 폐기 가능(disposability) / 개발, 테스트, 운영 환경의 일관성 / 로그 / 일회성 프로세스



##### FaaS

- FaaS(**Function** as a Service)
- 서비스의 수준을 기능 단위까지 세분하여 제공하는 기능 서비스
  - 최근 클라우드 플랫폼 사업자들은 인공지능(AI), 빅데이터(Big Data) 분석, 챗봇(ChatBot)과 같은 서비스에 사용되는 기능들을 더욱 상세하게 세분화해서 서비스로 제공하고 있다.



#### 클라우드 네이티브 아키텍처



##### 확장 가능한 아키텍처

- 시스템을 구성하는 소프트웨어들이 조각조각 마이크로서비스 형태이고, 필요에 따라 **수평으로 유연하게 증가**한다면 장애나 성능 초과 현상에 대한 대응책들이 아주 쉽게 설계되고 비용도 적게 들 것이다.
- 시스템의 수평적 확장에 대한 유연한 구조
  - 서비스의 연속성 보장
  - 시스템 부하 분산
  - 가용성이 보장
    - 가용성
      - 정상적으로 사용 가능한 정도



##### 탄력적 아키텍처

- 탄력적 아키텍처(resilience architecture)란, 서비스 생성-통합-배포, 비즈니스 환경 변화에 대응 시간을 단축, 오류를 예측하고 적절히 대응할 수 있는 아키텍처 구조이다.



##### 장애 격리

- 특정 서비스의 오류로 인해 다른 서비스까지 영향이 도달하는 것을 없애는 것이다.



#### 클라우드 네이티브 인프라



##### 컨테이너 기반 패키지

- 컨테이너 기반 패키지(container based package)란, **컨테이너 단위**의 패키지이다.
  - 패키지 단위가 **시스템 단위**일 수도 있고, **서비스 애플리케이션 단위**일 수도 있다.
  - **컨테이너로 패키지된 단위**가 실행 단위
    - 도커 컨테이너 기술이 소개되기 전에는 패키지 형태는 '.jar'나 '.war' 형태로 압축된 파일 타입이었다.
      - 도커 이미지로 패키지하면 도커 이미지를 받아서 컨테이너로 실행하면 된다.



##### 동적 관리

- 컨테이너 단위로 패키지된 서비스가 시스템에 추가되면, **시스템이 동적으로 컨테이너를 감지**하여 클라이언트부터 들어오는 서비스 요청을 자연스럽게 추가된 컨테이너의 서비스가 처리할 수 있도록 관리된다.



#### 지속적 통합과 배포



##### 지속적 통합(CI)

- 지속적 통합은 개발 환경에서 **개발 중인 코드를 통합**하고 필요에 따라 테스트를 병행 수행하는 일련의 프로세스를 의미한다.
- 작은 단위의 작업, 빈번한 적용
- **자동화**된 빌드와 테스트로 검증
- 지속적 통합을 위한 구성 요소로는 CI(Continuous Integration) 서버, 소스 관리(SCM, Source Code Management), 빌드 도구(tool), 테스트 도구가 있으며, CI 서버는 빌드 프로세스가 관리하는 서버이다.
- 지속적인 통합이라는 의미에서 알 수 있듯이 소스 저장소에 있는 소스를 기준으로 일정한 주기로 반복적으로 소스들을 빌드하여 실행 가능한 형태의 바이너리 상태인 파일로 만든다.
  - 빌드 과정과 주기는 자동화되어야 하고, 빌드 시간은 그리 오래 걸리지 않아야 한다.



##### 지속적 배포(CD)

- 애플리케이션 배포 자동화
- 짧은 주기로 소프트웨어를 생산하는 소프트웨어 공학적 접근법
- 여러 애플리케이션에 대한 변경사항, 동시 배포 관리 파이프라인
- CI 프로세스를 통과한 변경사항을 스테이징/운영 환경에 즉시 배포
- 상시, 신뢰성 있는 릴리즈 가능
- 지속적 배포의 두 가지 유형
  - **continuous delivery**
    - 빌드된 소스 코드의 실행 파일을 실행 환경 반영 전 단계까지 배포하는 방식
      - 실행 환경 반영을 위해서는 승인 및 배포 **담당자의 허가**를 받아야 배포할 수 있다.
  - **continuous deployment**
    - 소스 저장소에 빌드된 소스 코드의 실행 파일을 **실행 환경까지 자동으로** 배포하는 방식
  - 그림 2.10 참고
- 파이프라인
  - 통합 및 배포까지 일련의 프로세스를 하나로 연결하여 자동화 및 시각화된 프로세스를 구축
  - 그림 2.11 참고
- [지속적통합 CI, 지속적배포 CD]([https://zetawiki.com/wiki/%EC%A7%80%EC%86%8D%EC%A0%81%ED%86%B5%ED%95%A9_CI,_%EC%A7%80%EC%86%8D%EC%A0%81%EB%B0%B0%ED%8F%AC_CD](https://zetawiki.com/wiki/지속적통합_CI,_지속적배포_CD))

<img src="../../study/정리/책 정리/자바 기반의 마이크로서비스 이해와 아키텍처 구축하기.assets/image-20200807173440298.png" alt="image-20200807173440298" style="zoom:50%;" />



##### 카나리 배포와 블루그린 배포

- 빌드된 소스를 릴리스하는 두가지 배포 유형
  - **카나리(canary)** 배포
    - 새 버전의 서비스를 일부 사용자들에게만 배포하여 정상 유무를 확인하는 전략
  - **블루그린(blue-green)** 배포
    - 운영과 같은 환경이 하나 더 있고, 한쪽에 새로운 버전을 배포하여 사용자의 연결 요청을 새 버전 서비스로 라우팅을 유도하여 문제가 없으면 이전 환경의 사용을 중지한다.
      - 다음 버전 배포 때는 중지된 환경으로 새로운 버전을 배포하고, 다시 역할을 바꾼다.
- 그림 2.12 참고



#### 데브옵스



##### 팀의 구성

- 데브옵스 측면에서는 개발에서 운영까지를 하나의 파이프라인으로 형성하여 소스 코드의 배포가 필요할 때 즉시 반영되는 게 목표
  - 이를 위해서 가장 이상적인 팀 구성 모델은 서비스의 기획, 설계, 개발, 배포 및 운영까지 **서비스 생명주기(lifecycle)가 한 팀으로** 같은 작업 공간에서 결정되고 수행되는 것이다.
  - 이렇게 된다면 생명주기상에서 발생하는 의사소통과 의사결정을 위한 노력과 비용을 절감할 수 있다.
  - 원하는 시점에 즉시 서비스를 배포하고 운영할 수 있어 비즈니스 변화에 빠르게 대응할 수 있는 이점도 있다.



##### 자동화와 시각화

- 개발 프로세스와 운영 프로세스 간의 자연스러운 연결이 데브옵스의 핵심이라면 프로세스 전체의 과정이 자동화되고 시각화되는 것이 이상적인 환경
  - 깃, 젠킨스, 데시보드(Dashboard), 이슈 추적(Issue Tracker) 등 오픈소스 도구들을 활용하여 소스 코드를 빌드하고, 개발 진척 상황 및 배포 운영 상황 등이 공유되고 모니터링 되어야 한다.
  - 그림 2.14 참고



### 2.2 컨테이너



#### 컨테이너 개념

- 리눅스 운영체제에도 이러한 격리 개념이 있다. 운영체제상에서 독립된 공간을 할당하고 독립된 공간끼리는 서로 격리되어 독립된 자원을 할당받고 프로세스 간 간섭이 없다면 애플리케이션 입장에서는 자신만의 공간을 가지게 되고, 용도에 맞게 안전하게 실행될 수 있다.

- 컨테이너 단위의 독립된 공간 단위로 서비스를 패키지할 수 있으므로 격리된 만큼 필요한 자원을 할당하여 경량화된 서비스를 구성할 수 있고, 격리된 공간은 다른 서비스에 영향을 주지 않고 자유롭게 배포할 수 있다. 컨테이너의 수요가 많아지면, 즉 사용량이 증가하면 똑같은 컨테이너를 하나 더 구성하여 대응하기 편리한 확장을 제공한다.



##### 프로세스 격리

- 격리된 공간에서 수행되는 프로세스는 다른 공간에서 동작하는 프로세스에 영향을 받지 않는다. 
  - 네트워크 자원을 분할하면 별도의 IP 어드레스를 할당하여 액세스가 가능하다.
  - 그림 2.16 참고



##### 가상화와 컨테이너

- 가상화
  - **'하이퍼바이저(hypervisor)'라는 소프트웨어를 이용하여** 하나의 시스템에서 여러 개의 운영체제를 사용할 수 있게 지원하는 기술



- 컨테이너
  - **하이퍼바이저 없이** 컨테이너 엔진을 통해서 가상의 격리된 공간을 생성하는 기술
  - 호스트 운영체제의 자원을 공유하지만, 프로세스 간의 격리를 통해서 가상의 공간에 독립성을 부여하는 방식
  - 경량화된 컨테이너 구성이 가능하고 이러한 장점을 활용할 수 있는 시스템 구성에는 유용한 기술
- 그림 2.17 참고



#### 리눅스 컨테이너



##### 리눅스 컨테이너란?

- 컨네이너 기술을 적용하고 있고, 하나의 호스트 운영체제 위에 여러 개의 **격리된 시스템 환경을 구성**할 수 있는 운영체제 수준의 가상화 기술
- 리눅스 컨테이너는 **네임스페이스(namespace)**와 **컨트롤그룹(cgroups)**이라는 **커널(kernel)** 기능을 사용하여 격리된 공간을 관리한다.
- 그림 2.18 참고



##### 네임스페이스

- 네임스페이스(namespace)는 컨테이너별로 격리된 공간을 가질 수 있도록 지원하는 기술
- 네임스페이스는 그 이름으로도 짐작할 수 있듯이 고유의 이름을 가진 공간이라고 생각하면 이해하기 쉬울 것이다.
- 시스템을 구성하는 요소도 공간별로 할당하고 관리할 수 있다.
- 시스템 구성요소로는 'PID', 'NET', 'MNT', 'UID', UTS', 'IPC' 여섯 가지 네임스페이스를 제공
- Namespace isolation(namespaces)
  - 프로세스 트리, 사용자 계정, 파일시스템, IPC 등을 격리시켜 호스트와 별개의 공간을 만든다.
- 표 2.1 참고
- 여기에 대해서 스터디에서 얘기해보기



##### 컨트롤그룹

- 리눅스 커널의 컨트롤그룹(cgroups)은 CPU, 메모리, 디스크, 네트워크 자원을 할당하여 완전한 형태의 가상 공간을 제공

- 컨트롤그룹(cgroups)은 물리적인 하드웨어의 리소스를 프로세스 그룹 단위로 제어하는 커널 기능
  - 하드웨어의 리소스인 중앙처리장치, 메모리, 블록 입출력(block I/O), 네트워크, 디바이스 노드(device node - /dev) 등과 같은 자원을 뜻하며, **컨테이너의 재기동 없이 할당**할 수 있게 해주는 커널의 기능



#### 도커 컨테이너



##### 도커 이미지

- 도커 이미지(docker image)는 하나 혹은 여러 개의 이미지 레이어로 구성되어 있고, 도커엔진에서 사용하는 기본 단위이다.
- 베이스 이미지(base image)
  - 리눅스 배포판의 커널을 제외한 영역을 이미지로 만들어 시스템을 부팅할 때 필요한 최소한의 실행 파일과 라이브러리만으로 베이스 이미지를 구성하여 배포
- 도커 이미지
  - 베이스 이미지 위에 필요한 라이브러리나 실행 파일 등을 추가하거나 불필요한 파일들을 삭제하여 만든 이미지



##### 도커 컨테이너

- 도터 컨테이너(docker container)는 도커 이미지를 독립된 공간을 할당하여 실행한 런타임 객체(runtime object)이다.
- 도커 엔진(docker engine) 위에서 기동되며 가상의 IP와 포트, 이름을 가질 수 있다.
- 프로세스 간 격리된 환경으로 독립적으로 실행
- 그림 2.20 참고 



##### 도커 레지스트리

- 도커 레지스트리(docker registry)는 도커 이미지를 관리할 수 있게 제공된 저장 공간이다.



##### 도커 네트워크

- 도커 네트워크(docker network)는 도커 컨테이너 단위로 서비스할 수 있도록 네트워크 환경을 제공하는 가상의 네트워크 환경
- 그림 2.22 참조

  - eth0

    - 외부에서 퍼블릭 네트워크로 들어오는 연결은 물리 NIC(eth0)와 연결

  - dorker0

    - NIC(eth0)는 도커 내부 네트워크와 브리지 역할을 하는 docker0와 연결
    - docker0은 도커 내부 컨테이너들의 가상의 NIC(veth)와 연결되어 접속할 수 있다.

  - vethXXX - eth0

    - 도커 내부 컨테이너들은 각자 가상의 eth0에 IP가 자동으로 할당되어서 docker0에서는 컨테이너의 IP를 확인하여 연결할 수 있다.

  - 도커 데몬 NIC - (중간에 docker0, vethXXX) - 도커 컨테이너 NIC

  - NIC(Network Interface Card)

  - NAPT(Network Address Port Translation)

    - 하나의 IP를 가지고 가상의 여러 IP 및 포트와 변환하는 기능
    - NAPT는 포트까지 변환하여 1:N으로 변환하는 방식
    - 도커 네트워크는 NAPT 기능을 사용

    - 사용자 http://www.hoony.com:8080 - > eth0 8080 - > docker0 - > 컨테이너1번(80 port)
      - 스터디에서 얘기 나눠보기 

  - NAT(Network Address Translation)

    - 공용 IP와 사설 IP의 관계, 즉 'Public IP : Private IP' 관계가 1:1로 변환하는 방식
- [블로그 참고](https://jonnung.dev/docker/2020/02/16/docker_network/)



##### 도커와 마이크로서비스

- 마이크로서비스는 독립된 서비스이고, 이를 실행하기 위한 환경 측면에서 도커 컨테이너는 잘 어울리는 기술의 조합



## CHAPTER 03 마이크로서비스 이해와 기획



### 3.1 마이크로서비스 이해



#### 마이크로서비스 개념



##### 마이크로서비스란?

- 모놀리스(monolith) 애플리케이션에서는 모든 기능이 하나의 큰 애플리케이션 형태로 실행 배포된다.
  - 내부를 들여다보면 업무적으로 비슷한 것들은 그룹을 지어 패키지로 분리하지만, 전체적으로 하나의 큰 덩어리로 실행된다.
- 마이크로서비스는 논리적으로 분리할 수 있는 기능들이 분리 구성되어 독립적으로 실행할 수 있는 애플리케이션이다.



##### 마이크로서비스와 아키텍처

- 마이크로서비스와 마이크로서비스 아키텍처는 **조금 다른 주제**
- 서비스는 '업(業)'을 이해하고 현재보다 유연한 사업 구조를 만들기 위한 **분석 활동의 결과물**
- 마이크로서비스 아키텍처는 잘 분할되어 식별된 결과물을 **효과적이고 효율적으로 잘 설계하기 위한 아키텍처적인 접근**이다.



##### 마이크로서비스의 특징 - 작은 서비스

- **서비스**는 **비즈니스**보다 작은 개념이다.
  - 독립된 비즈니스가 아닌 독립된 서비스이다.
  - 서비스들이 합쳐져 작은 비즈니스가 된다.
- **작은 서비스를 식별하기 위한 이론**은 에릭 에반스(Eric Evans)가 지은 **<도메인 주도 설계(Domain Driven Design)>**에서 잘 설명하고 있다.
  - 책에 나오는 서비스의 경계를 나누고 서비스를 식별하는 기준
    - 바운디드 콘텍스트(bounded context)
      - 하나의 서비스에 담을 수 있는 기능들의 그룹이자 서비스 수준의 경계
    - **'보편적 언어'(ubiquitous language)**
      - 같은 업무를 하는 사람들은 업무상 사용하는 단어와 용어의 뜻이 같다는 것
      - 같은 단어라도 부서에 따라 뜻이 다르게 해석될 수 있다.
      - 업무의 관심 영역이 다르고, 그 업무에서 사용하는 단어와 용어들의 의미가 다르기 때문
      - '보편적 언어' 기준의 예
        - 고객의 계약 상태를 관리하기 위한 '계약 관리 기능'의 '고객'의 의미는 '가입자'
        - 고객의 의견을 접수하는 콜 센터(call center) 접점 업무인 'VOC(Voice Of Customer)'의 고객은 '상담 접수자'
      - 그림 3.4 참고



##### 마이크로서비스의 특징 - 독립된 서비스

- 독립적으로 실행할 수 있고, 다른 서비스들과 결합이 없는 서비스
- 구현과 배포 실행 측면의 독립성도 있겠지만, 장애에 대한 영향도 측면에서도 영향을 받지 않는다.
  - 어느 한쪽의 서비스가 문제가 되어 다른 서비스에 영향이 전가되어서는 안 된다.
    - 모놀리스 애플리케이션이라면 특정 기능 한 곳에서 문제가 된다면 렌터카 대여 비즈니스 자체가 불가능한 상황이 발생할 것이다.



##### 마이크로서비스의 특징 - 응집된 서비스

- 하나의 서비스는 기능적으로 응집되어 있어야 한다.
  - 서비스의 역할이 한 가지 일을 하기 위해 뭉쳐 있어야 하고, 그 일을 해결하기 위한 기능에 집중한다는 것
  - 한가지 목적에 집중할 때 코드는 단순 명확해지고 요류 발생 확률도 최소활 될 것이다.
  - 응집된 서비스의 예
    - '수강 신청' 서비스에서는 수강 신청과 관련된 행위에 집중하는 것이고, '개설 과목'이나 '수강 일정' 등은 각각 다른 서비스로 개발되어야 한다.



##### 마이크로서비스의 특징 - 자율적 서비스

- 자율적 서비스는 서비스를 기획, 개발, 테스트, 배포 및 서비스의 운영까지 **담당 조직(팀)이 독립적**으로 의사결정을 하고, 서비스에 대한 소유권(ownership)을 가지고 관리되는 서비스이다.



### 3.2 마이크로서비스 기획

- 프로젝트 현장에서 마이크로서비스를 기획하기 위해서는 마이크로서비스 아키텍처 구축 체계를 수립하고 적절한 크기의 서비스를 도출하기 위한 서비스 식별 전략이 필요하다.



#### 마이크로서비스 식별 전략

- 업무 영역에서 마이크로서비스를 식별하는 일은 개념적이면서도 정답이 없는 활동이다.
  - 해당 도메인의 전체 흐름을 완벽하게 이해하고 업무의 중요도를 가려 서비스를 식별하는 것은 현실적으로 어렵다.
  - 분석하는 사람의 경험과 지식, 그것도 각자의 관점과 주관이 개입될 수밖에 없는데 그렇다고 직감으로 이야기할 수는 없다.
  - 모든 아키텍처는 근거가 있어야 하고, 마이크로서비스 아키텍처의 핵심인 마이크로서비스 또한 **식별 근거**가 명확해야 한다.



##### '업(業)' 도메인 이해

- 사용자 유형 분석
  - 사용자 유형을 분석하는 방법은 도메인의 비즈니스를 이해하는 가장 첫 단계
  - 사용자의 분류와 역할을 이해하는 것만으로도 업무의 큰 흐름을 이해할 수 있고, 핵심 비즈니스가 무엇인지 개략적으로 파악할수 있다.
- 업무 흐름 분석
  - 데이터 간의 관계를 배제하고 **서비스 수준에서 업무의 흐름을 분석**
    - 업무의 흐름을 분석해서 순서를 구분하여 별도의 서비스라고 가정
      - 선행 업무의 경과를 후행 업무에서 참조해야 할 상황이면 실시간으로 참조하는지 약간의 시간 간격이 있어도 되는지 등 흐름을 기준으로 경계를 나눈다.
- 핵심 업무 및 우선순위
  - 업무 중에서는 핵심이 되는 업무와 비핵심 업무가 있을 것이다.
    - 비핵심 업무 중에는 핵심 업무와 관련이 있는 업무와 그렇지 않은 업무가 있을 것이다.
  - 서비스의 경계를 식별하고 분류한는 세 가지 주된 관점
    - 공용 서비스
      - 대부분 온라인 시스템에는 인증 권한, 사용자 관리, 공지사항, 메일, 푸시 같은 기능들이 기본적으로 제공된다.
    - 일반적인 서비스
      - 시험, 평가, 설문, 과제  같은 기능들은 교육 시스템에서 기본적으로 제공해야 하는 기능이다.
    - 특화 서비스
      - 구축 중인 목표 시스템에만 있는 차변화된 기능
- 상관 분석
  - 마이크로서비스의 핵심은 서비스의 결합 관계를 낮추고 데이터 간 연관성을 최소화하여 독립된 서비스들로 구성된 서비스를 만드는 것
    - 소프트웨어 공학에서 이야기하는 '관심사의 분리', '낮은 결합도'와 '높은 응집도'등 고품질의 소프트웨어를 만들기 위한 원리와 맥락을 같이 한다.
  - 서비스 간 적절하지 않은 포함 관계나 참조 관계를 파악해서 수평적 관계로 변경
  - 데이터 상관관계를 제거해 서비스 독립적인 데이터베이스 구축
    - 상관관계
      - 두 가지 가운데 한쪽이 변화하면 다른 한쪽도 따라서 변화하는 관계
    - 서로 다른 스키마나 데이터베이스의 데이터는 되도록 데이터의 직접 접근이 아닌 서비스를 호출하여 접근하는 방향으로



##### 마이크로서비스 원칙 수립

- 서비스 경계
  - 서비스 분할 기준이 있어야 한다.
  - **조직을 기준으로** 서비스를 구성할 건지 **서비스의 업무 중요도**에 따라 서비스의 경계를 구분할 것인지 등을 판단해야 한다.
- 서비스 분할
  - 하향식 접근
    - 업무의 흐름을 기준으로 핵심적인 업무와 비핵심적인 업무를 나누고, 어느 도메인에서나 사용 사능한 업무 등으로 분류할 수 있다.
      - 이렇게 분할된 업무 단위를 서비스라 하는데, 이는 서비스에 사용하기 위한 데이터를 서비스별로 정의하는 접근법
  - 상향식 접근
    - 상향식 접근이란, 데이터의 특성을 고려하여 분할하는 것.
    - 하향식 접근이든 상향식 접근이든 마이크로서비스의 목표는 서비스를 작게 분할하고, **서비스를 위한 데이터는 그 서비스에 한정하여 참조**하는 것.
  - 점진적 분할
    - 가장 현명한 방법은 **비즈니스 영향이 덜한 서비스들부터** 하나씩 점진적으로 바꿔 나가는 것.
    - 메인 프로세스처리와 직접적인 관련이 없는 영역을 별도로 분리해 조금씩 마이크로서비스화하는 전략



##### 상관관계 분석

- 서비스와 데이터 간 종속성
  - 모놀리스 환경에서는 일반적으로 통합 데이터베이스에서 데이터를 통합하여 운영
    - 만약 이와 같은 시스템적인 환경을 바꿀 수 없는 경우라면 최소한 데이터 간 논리적인 경계를 구분할 수 있는 **스키마 단위**로 나누는 방법이 일반적인 접근일 것이다.
- 서비스 간의 종속성
  - 서비스 후보 기능 간의 사용 관계 분석을 통해서 기능 간의 결합도를 파악할 수 있다.
  - 프로그램 코드 수준의 분석이 아닌 업무 기능 단위 수준에서 분석의 수준을 정해야 한다.
  - 후보 기능들은 나중에 마이크로서비스로 식별되어 정의될 것이고, 이들 간의 호출 관계는 기능 간 사용 관계, 즉 기능 내부의 함수 호출에서 **HTTP 프로토콜 기반의 REST URI 호출**로 변경될 것이다.
- 데이터 간의 종속성
  - 데이터 간의 종속성을 분리하기 위해서는 마이크로서비스 단위별로 데이터베이스를 분리하는 것을 권한다.
  - 데이터베이스를 분리 구성할 수 없는 경우 **스키마를 분리**하여 서비스에 대응하는 방법도 있다.
    - 스키마 구분을 이용한 데이터의 경계 구분은 데이터의 주제 영역과 관련이 있다.
    - 데이터 간 결합도를 최소화할 수 있는 논리적 구분 방법의 하나라고 할 수 있다.
  - 통합된 데이터베이스를 운영하다가 여러 개로 나뉜 데이터베이스를 사용하면 트랜잭션 처리를 어떻게 보장하는가?
    - 데이터베이스 수준의 트랜잭션이 아닌 설계 단계에서부터 서비스 수준에서 처리하거나 혹은 큐(queue) 매커니즘을 이용하여 데이터를 동기화하는 구조를 생각해 볼 수 있다.
      - 되도록이면 마이크로서비스 단위로 독립적으로 데이터 설계가 되어야 하고, 부득이한 경우 데이터 속성을 중복해서 가지는 것을 허용하고, 큐와 같은 매커니즘을 이용해서 서로 다른 마이크로서비스 간의 데이터를 비동기적으로 맞춰 주는 것.



##### 마이크로서비스 식별

- 도메인을 이해하고 도메인 내에서의 '사용자 유형', '업무 흐름', '조직의 구성' 등과 업무 처리를 위해 부서별로 사용하는 '언어', '용어' 등의 요소들은 서비스의 영역을 구분 짓고 마이크로서비스를 식별할 수 있는 충분한 단서가 된다.
  - 이렇게 식별된 서비스에는 고유의 주소를 부여하여 유일한 서비스로서 독립성을 가지게 된다.
  - 서비스에 부여된 주소를 이용하여 필요에 따라 다른 서비스를 참조할 수 있다.



#### 마이크로서비스를 위한 고려 사항



##### 조직의 구성

- 서비스를 운영하는 조직은 소규모의 팀 단위로 구성되어야 한다.
  - 조직의 규모가 크다는 것은 관리할 요소가 많고 이해관계가 복잡하다는 것을 뜻한다.
    - 의사결정을 위한 프로세스도 많아지고, 서비스를 만들고 배포하는 시간도 자연스레 늘어난다.
  - 마이크로서비스에 맞는 조직의 구성과 조직의 권한까지 위임하는 것이 이상적인 모습이라 할 수 있다.
  - 운영 측면의 조직도 중요하지만, 시스템 구축 단계의 조직 구성도 생각해 봐야 한다.



##### 애자일과 데브옵스의 테일러링

- 마이크로서비스의 궁극의 목표는 민첩한 서비스이다.
- 애자일 방법론과 데브옵스 체계는 마이크로서비스의 기획에서 배포 생명주기와 궁합이 잘 맞는다고 할 수 있다.
  - 기획에서 배포까지 빠르게 개발해서 배포할 수 있는 방식은 **애자일 방법론**에서 강조하는 반복적이고 점짐적인 개발 방법과 소통의 문화와 일맥상통한다.
  - 기획에서 개발, 빌드, 테스트, 배포, 운영까지 자동화, 시각화할 수 있는 체계는 **데브옵스**의 지향점과도 맥락을 같이한다고 할 수 있다.
- 클라우드 네이티브 기술 환경
  - 마이크로서비스는 결국 작은 서비스를 얼마나 빠르게 운영 환경에 독립적으로 배포 실행할 수 있느냐가 핵심이다.
  - 최근 클라우드 환경의 발전과 더불어 세계적인 플랫폼 사업자들은 애플리케이션을 쉽고 빠르게 만들어 실행하고 운영 관리할 수 있는 환경까지 제공한다.
  - 애플리케이션 측면에서도 논리적으로 독립된 가상의 격리 환경을 제공하는 도커 컨테이너 기술의 활용 확산으로 **소스를 패키지하는 방식** 자체가 변했다.
  - 클라우드 네이티브 기술 환경의 발전은 마이크로서비스를 넘어 기능 단위 서비스까지 확대 발전을 더욱 가속화하고 있다.



## CHAPTER 04 마이크로서비스 아키텍처 설계

### 4.1 마이크로서비스 설계

- 마이크로서비스 본질에 대한 고민과 이렇게 만들어진 서비스의 빠른 개발과 배포, 그리고 안정적이고 효율적인 운영을 위한 아키텍처 구조 설계로 나누어 생각해 볼 수 있다.
  - **마이크로서비스**는 작은 서비스에 집중
    - 서비스 대상을 무엇으로 할 것인가?
    - 서비스의 크기는 어느 정도의 크기가 적당한가?
    - 서비스 간의 결합도는 낮은가?
    - 서비스는 응집성이 높은가?
  - **아키텍처**는 기술적인 요소에 집중
    - 마이크로서비스의 가용성을 보장할 수 있는 아키텍처 구조는 무엇인가?
    - 탄력성 있는 기술 구조는 어떻게 구성해야 하는가?
    - 서비스 간에 어떠한 프로토콜로 연계를 하는 게 적절한 방법인가?



#### 커피 전문점 서비스 이해



##### 커피 전문점 서비스 개요



##### 사례



##### 서비스 대상은 무엇이며 크기는 적절한가?

- 서비스 경계의 기준
  - 업무의 흐름
    - 업무의 흐름이란, 커피 주문 처리, 커피 제조, 주문 처리 상태 알림 처럼 업무 간의 **절차**가 있고, 절차상에서 **관심사**가 서로 다르다는 것을 이해할 수 있다.
  - 업무의 중요도
    - 핵심 업무와 비핵심 업무 그리고 공통으로 제공해야하는 업무들로 분류하는 것
  - 업무의 형태
    - 실시간으로 해결되어야하는 것인지 아니면 일 단위, 월 단위로 처리되어야 하는 일인지에 대한 분류



#### 커피 전문점 마이크로서비스 개념 설계



##### 커피 전문점 마이크로서비스 식별

- 그림 4.6 참고



##### 커피 전문점 업무 간 관계



##### 화면 설계

- 그림 4.8 참고



##### 서비스 설계



##### 데이터 설계



##### 메시지 전송 방식 설계

- 그림 4.12 참고



#### 커피 전문점 마이크로서비스 구조 설계



##### 마이크로서비스 프로젝트 구조 설계

- 마이크로서비스 프로젝트 계층 관계
  - 복수 프로젝트 구성
    - 하나의 프로젝트 하위에 N개의 하위 프로젝트를 구성할 수 있고, 하위 프로젝트들 각각 독립된 마이크로서비스로 동작한다.
    - 그래들 멀티 모듈 프로젝트
  - 독립 프로젝트 구성
    - 마이크로서비스 하나당 독립된 프로젝트를 구성하고, 팀 특면에서는 N개의 독립된 프로젝트를 담당할 수 있다.



##### 커피 전문점 마이크로서비스 프로젝트 구조 설계

- 그림 4.17 참고



##### 커피 전문점 마이크로서비스 프로젝트



##### 커피 주문 마이크로서비스 패키지 구조 설계

- 도메인 영역과 기술 영역 분리
  - 그림 4.20
    - 모델, 레파지토리는 왜 모델 영역과 기술 영역에 둘 다 있는거지
      - 도메인 영역에서 서비스에 필요한 핵심 로직을 만들고, 스프링부트 영역에서는 도메인 영역에서 만들어진 서비스를 시스템 환경에서 실행 될 수 있게 구현하는 구조?
        - 캐시성, 합쳐진 데이터
        - 도메인 영역에서 만들어진 서비스를 시스템 환경에서 실행 될 수 있게 스프링부트 영역에서 모으고 하는 역할을 하는거 같다. 필요하면 레파지토리로 디비에서 데이터도 가지고 오고.



### 4.2 마이크로서비스 아키텍처 설계



#### 마이크로서비스 아키텍처 구성



##### 환경 설정

- 외부 환경 설정 관리(externalizing configuration)
  - 시스템에서 참조해야 하는 환경 설정 정보(환경 변수) 등을 별도의 저장소에서 관리하여 애플리케이션이 배포된 환경에 구애받지 않고 해당 환경에 적절한 환경 정보들을 참조할 수 있는 기능을 제공하는 서비스이다.
    - 환경 설정 정보는 IP, Port, 서비스명, 변수 등이 될 수 있다.



##### 서비스 등록과 감지

- 마이크로서비스가 시스템 등록되는 것을 자동으로 감지하여 서비스 게이트웨이(service gateway)가 자동으로 인지할 수 있게 지원하는 기능
  - 그림 4.26에서 '주문 처리 상태 확인 서비스'가 추가되면 서비스 등록/감지 에코시스템이 이를 감지하고, 서비스 게이트웨이에서는 서비스 라우팅 대상에 추가한다. 
  - Eureka



##### 서비스 게이트웨이

- 마이크로서비스에 대한 요청을 받아서 해당 요청에 필요한 서비스로 연결해 주는 역할을 한다.
  - 클라이언트 관점에서 서비스 게이트웨이는 서버에 접속하기 위한 관문이고, 서버 측면에서는 클라이언트 요청의 부하 분산과 대응하는 적절한 마이크로서비스를 찾아 주는 역할을 수행한다.
  - 마이크로서비스가 기동될 때 서비스 등록 및 감지 서비스에게 해당 마이크로서비스가 새롭게 등록되어 시작된다는 상태를 전달한다.
  - Zuul



##### 서킷 브레이크

- 특정 서비스가 정상적으로 동작하지 않을 경우 다른 기능으로 대체 수행시켜서 장애를 회피하는 기능
  - 실제로는 해당 서비스에 문제가 있어 정상적으로 제 기능을 수행할 수 없지만, 최종 사용자 측면에서는 장애 상황을 인지할 수 없다.
    - 대체 기능으로 정상인 것처럼 응답하기 때문에
  - 결국 사용자가 시스템적인 장애를 인지하지 않아도 될 무관한 업무 형태나 정보 제공 형태의 서비스에 제공하면 아주 유용한 기능
  - Hystrix



##### 큐잉 시스템

- 마이크로서비스 간 데이터의 전달이 필요하고 느슨한 결합을 위해서 큐잉 시스템(queueing system)을 사용한다.
  - 카프카(Kafka) 같은 메시지 큐가 대표적인 시스템이라 할 수 있다.
  - 서비스에 직접적인 부하를 주지 않고 필요한 서비스들만 구독해서 사용하면 되는 장점이 있다.
    - 강한 결합이 없게



##### CQRS와 이벤트 소싱

- CQRS(Command and Query Responsibility segregation)

  - 명령을 처리하는 책임과 조회를 처리하는 책임을 분리 구현한다는 개념
  - 읽기를 위한 데이터 저장소와 쓰기를 위한 데이터 저장소를 분리 구성
    - 쓰기 작업이 읽기 작업에 영향을 받지 않고 독립적으로 상호 수행할 수 있게 설계하는 사상
    - 저장소를 따로 가져간다? 동기화는 어떻게 하지?

- **이벤트 소싱**(event sourcing)은 애플리케이션이 실행될 때 발생되는 모든 이벤트 스트림(event stream)을 별도의 데이터베이스에 저장하는 방식

  - 이벤트 스트림이 저장되는 데이터베이스를 이벤트 스토어(event store)라고 한다.
  - 저장되는 모든 이벤트 스트림 데이터는 이벤트 스토어에 추가만 되고, 이렇게 쌓인 데이터는 사용되는 시점에 이미 구축된 데이터를 기준으로 가공하여 사용한다.

  - 즉, 애플리케이션의 상태 변경을 이력으로 관리하는 패턴의 발전된 형태라 할 수 있다.
  - 이벤트 소싱을 더 공부를해서 별도로 빼서 정리. 



##### 폴리그랏 프로그래밍과 폴리그랏 퍼시스턴스

-  폴리그랏 프로그래밍(polyglot programming)
   - 서비스별로 목적과 특성에 맞는 언어와 기술을 사용하는 프로그래밍 방식이다.
-  폴리그랏 퍼시스턴스(polyglot persistance)
   - 데이터의 성격과 목적에 맞는 데이터베이스를 사용하는 여러 유형의 데이터베이스를 혼용하여 사용하는 방식
     - 회원 관리와 같은 정형화된 데이터를 관리하기 위해 관계형 데이터베이스를 사용
     - 문서 형태의 콘텐츠를 주로 다룬다면 이에 적합한 도큐먼트형 데이터베이스를 사용
     - 비정형 데이터 형식의 콘텐츠를 다루고 키밸류(key-value) 형태의 검색 조회가 필요하다면 키밸류형 데이터베이스를 사용 



#### 서비스 구성 체계



##### API 버전

- 메시지의 키 값이 변경되는 경우는 메이저 변경을 해야한다.
  - 버전1 메이저 버전
  - 버전2 메이저 버전
- 메시지에 키 값과 데이터가 추가된다면 마이너 변경을 만들면 된다.
  - 버전1 메이저 버전
  - 버전1.1 마이너 버전



##### REST API



##### 무상태 프로토콜



#### 테스트 체계



##### 서비스 계약



##### API 테스트



##### 콘트렉트 테스트

- 생산자? 소비자? 사용자가 YAML 파일 형식으로 계약 명세서를 작성?
  - 그래들에서 테스트 하는게 아니라 말아서 실행시켜 놓고 테스트하는걸 얘기하는 거 같다.
    - Acceptance Test도 가라로 서버를 띄어놓고 테스트 하는디



#### 지속적 통합 및 배포체계 설계



##### 지속적 통합 및 배포(continuous integration & delivery)



##### 파이프라인

- 파이프라인 파이프라인 하는데 뭐지
  - 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 가리킨다.
    - 리눅스에서 이 용어를 쓰던데
    - 여러 동작을 순서가 있게 모아서 실행하는 느낌? 



#### 모니터링 체계 설계



##### 서비스 모니터링(service monitoring)



##### 데브옵스 모니터링








## CHAPTER 05 마이크로서비스 구현

### 5.1 마이크로서비스 구성

#### 개발 환경 구성

#### 커피 전문점 마이크로서비스 구성도 및 구성 요소

### 5.2 마이크로서비스 구현

#### 커피 주문 마이크로서비스 구현

#### 회원 확인 마이크로서비스 구현

## CHAPTER 06 마이크로서비스 아키텍처 구축

### 6.1 마이크로서비스 아키텍처 구성

#### 스프링 클라우드 아키텍처 참조 모델

#### 스프링 클라우드 아키텍처 구성 요소

#### 커피 전문점 마이크로서비스 아키텍처 구성도 및 구성 요소

### 6.2 커피 전문점 마이크로서비스 아키텍처 구축

#### 설정 서버

#### 유레카 서버

#### 줄 서버

#### 터빈 서버

#### 히스트릭스 대시보드 서버

## CHAPTER 07 마이크로서비스 빌드 배포

### 7.1 마이크로서비스 빌드 단위

#### 독립 프로젝트

#### 복수 프로젝트

### 7.2 마이크로서비스 배포 형태

#### 실행 가능한 압축 파일

#### 도커 이미지

### 7.3 소스 빌드 및 패키징

#### ‘jar’ 빌드 및 패키징

#### ‘war’ 빌드 및 패키징

#### 도커 이미지 빌드 및 패키징



