

## 1장 IoC 컨테이너와 DI




## 1.1 IoC 컨테이너: 빈 팩토리와 애플리케이션 컨텍스트

- IoC (Inversion of Control)
  - 오브젝트의 생성과 관계설정, 사용, 제거
    - 스프링 애플리케이션에서는 애플리케이션 코드 대신 독립된 컨테이너가 담당한다.
      - 컨테이너가 코드 대신 오브젝트에 대한 제어권을 갖는다.

- 스프링 컨테이너를 IoC 컨테이너라고도 한다.
- 스프링에서 IoC를 담당하는 컨테이너
  - 빈 팩토리
    - 오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 때는 컨테이너를 빈 팩토리라고 한다.
  - 애플리케이션 컨텍스트
    - DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는 데 필요한 여러 가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트라고 한다.
- 스프링의 IoC 컨테이너는 일반적으로 애플리케이션 컨텍스트를 말한다.
- `ApplicationContext` 인터페이스는 `BeanFactory` 인터페이스를 상속한 서브인터페이스다.
  - 실제로 스프링 컨테이너 또는 IoC 컨테이너라고 부르는 것은 `ApplicationContext` 인터페이스를 구현한 클래스의 오브젝트다.
- 스프링 애플리케이션은 최소한 하나 이상의 IoC 컨테이너, 즉 애플리케이션 컨텍스트 오브젝트를 갖고 있다.



### 1.1.1 IoC 컨테이너를 이용해 애플리케이션 만들기

- `StaticApplicationContext ac = new StaticApplicationContext();`
  - 가장 간단하게 IoC 컨테이너를 만들었다.
  - 컨테이너가 본격적인 IoC 컨테이너로서 동작하려면 두 가지가 필요하다.
    - POJO 클래스
    - 설정 메타정보



#### POJO 클래스

- 각자 기능에 충실하게 독립적으로 설계된 POJO 클래스를 만들고, 결합도가 낮은 유연한 관계를 가질 수 있도록 인터페이스를 이용해 연결
  - IoC 컨테이너가 사용할 POJO를 준비하는 첫 단계
  - Hello 클래스에 Printer 인터페이스 타입 객체를 DI



#### 설정 메타정보

- 스프링 컨테이너가 관리하는 오브젝트는 빈이라고 부른다.
- IoC 컨테이너가 필요로 하는 설정 메타정보란
  - 빈을 어떻게 만들고 어떻게 동작하게 할 것인가에 관한 정보
- 스프링의 설정 메타정보는 `BeanDefinition` 인터페이스로 표현되는 순수한 추상 정보다.
  - `BeanDefinitionReader` 인터페이스
    - 원본의 포맷과 구조, 자료의 특성에 맞게 읽어와 `BeanDefinition` 오브젝트로 변환해 준다.
  - 스프링의 메타정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지 않는다.
    - XML
    - 소스코드 애노테이션
    - 자바 코드
    - 프로퍼티 파일
- 애플리케이션 컨텍스트는 `BeanDefinition`으로 만들어진 메타정보를 담은 오브젝트를 사용해 IoC와 DI 작업을 수행한다.
  - `그림 1-2` IoC 컨테이너를 통해 애플리케이션이 만들어지는 방식 참고
- `BeanDefinition` 인터페이스로 정의되는, IoC 컨테이너가 사용하는 빈 메타정보
  - 빈 아이디, 이름, 별칭
    - 빈 오브젝트를 구분할 수 있는 식별자
  - 클래스 또는 클래스 이름
    - 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보
  - 스코프
    - 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
  - 프로퍼티 값 또는 참조
    - DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
  - 생성자 파라미터 값 또는 참조
    - DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
  - 지연된 로딩 여부, 우선 빈 여부, 자동와이어링 여부, 부모 빈 정보, 빈팩토리 이름 등



```java
// 리스트 1-5 Hello 클래스 빈 등록
StaticApplicationContext ac = new StaticApplicationContext();
ac.registerSingleton("hello1", Hello.class); //빈 이름과 POJO 클래스 제공

Hello hello1 = ac.getBean("hello1", Hello.class);
assertThat(hello1, is(notNullValue()));
```

- 스프링 빈 메타정보의 항목들은 대부분 디폴트 값이 있다.
  - 싱글톤으로 관리되는 빈 오브젝트를 등록할 때 반드시 제공해줘야 하는 정보는 빈 이름과 POJO 클래스뿐이다.
  - 엥간한 메타정보는 Hello.class 같은 클래스 타입인 클래스 리터럴에 있을거 같은디

- IoC 컨테이너가 관리하는 빈은 오브젝트 단위지 클래스 단위가 아니다.
  - 같은 클래스의 빈을 여러 개 등록하고 빈마다 다른 설정을 지정해두고 사용할 수도 있다.



```java
// 리스트 1-6 BeanDefinition을 이용한 빈 등록
BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
ac.registerBeanDefinition("hello2", helloDef);

Hello hello2 = ac.getBean("hello2", Hello.class);
assertThat(hello2.sayHello(), is("Hello Spring"));
assertThat(hello1, is(not(hello2))); // 동일한 타입이지만 별개의 오브젝트임.
assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(2)); // 빈 설정 메타정보를 가져올 수 있다.
```

- 리스트 1-6은 직접 `BeanDefinition` 타입의 설정 메타정보를 만들어서 IoC 컨테이너에 등록하고 있다. 



### 1.1.2 IoC 컨테이너의 종류와 사용 방법

- 스프링을 사용하는 개발자가 직접 `ApplicationContext` 인터페이스를 구현할 일은 없을 것이다.
  - 이미 스프링에는 다양한 용도로 쓸 수 있는 십여개의 `ApplicationContext` 구현 클래스가 존재한다.
- `ApplicationContext` 오브젝트를 직접 코드를 통해 생성하는 경우도 거의 없을 거다.
  - 대부분 간단한 설정을 통해 자동으로 만들어지는 방법을 사용한다.



#### StaticApplicationContext

- 실전에서는 사용하면 안 된다.
  - 테스트 목적으로 코드를 통해 빈을 등록하고 컨테이너가 어떻게 동작하는지 확인하고 싶을 때를 대비해 이런 컨테이너가 있다는 정도만 기억해두자.




#### GenericApplicationContext

- XML 파일과 같은 외부의 리소스에 있는 빈 설정 메타정보를 리더를 통해 읽어들여서 메타정보로 전환해서 사용한다.
  - 빈 설정 리더를 만들기만 하면 어떤 형태로도 빈 설정 메타정보를 작성할 수 있다.
- 역시 직접 사용할 일은 아마 없을 거라고
  - JUnit은 테스트 내에서 사용할 수 있는 애플리케이션 컨텍스트를 자동으로 만들어 주는데 이때 생성되는 애플리케이션 컨텍스트가 `GenericApplicationContext`



#### GenericXmlApplicationContext

- 코드에서 `GenericApplicationContext`를 사용하는 경우에는 번거롭게 `XmlBeanDefinitionReader`를 직접 만들지 말자.
  - 대신 이 두 개의 클래스가 결합된 GenericXmlApplicationContext를 편리하게 사용하자.



#### WebApplicationContext

- 웹 애플리케이션에서 만들어지는 스프링 IoC 컨테이너는 `WebApplicationContext` 인터페이스를 구현한 것이다.
- `WebApplicationContext`는 `ApplicationContext`를 확장한 인터페이스
  - XML 설정파일을 사용하도록 만들어진 `XmlWebApplicationContext` 
    - 디폴트고 가장 많이 사용된다.
  - 애노테이션을 이용한 설정 리소스만 사용한다면 `AnnotationConfigWebApplicationContext`



### 1.1.3 IoC 컨테이너 계층구조



#### 부모 컨텍스트를 이용한 계층구조 효과

- 모든 애플리케이션 컨텍스트는 부모(루트) 애플리케이션 컨텍스트를 가질 수 있다.
  - 이를 이용하면 트리구조의 컨텍스트 계층을 만들 수 있다.
  - `그림 1-4` 컨테이너 계층 구조 참고
- 계층구조를 이용하는 이유
  - 기존 설정을 수정하지 않고 사용하지만 일부 빈 구성을 바꾸고 싶은 경우
    - 애플리케이션 컨텍스트를 두 개 만들어서 하위 컨텍스트에서 바꾸고 싶은 빈들을 다시 설정
  - 여러 애플리케이션 컨텍스트가 공유하는 설정을 만들기 위해

- 자식 컨텍스트는 부모 컨텍스트의 빈을 사용할 수 있지만 그 반대는 안 된다.
  - 검색 순서는 항상 자신이 먼저이고, 그런 다음 직계 부모의 순서다.



#### 컨텍스트 계층구조 테스트

- 자식 컨텍스트의 빈이 부모 컨텍스트 빈과 중복될 때는 자식 컨텍스트의 것이 우선한다.
  - 중복 빈 정의를 계층구조 내에서 허용한다고 하더라도 부모/자식 컨텍스트에 중복해서 빈이 정의되는 일은 가능한한 피해야 한다.



### 1.1.4 웹 애플리케이션의 IoC 컨테이너 구성



#### 웹 애플리케이션의 컨텍스트 계층구조

- 서블릿 애플리케이션 컨텍스트 >>> 웹 애플리케이션 루트 애플리케이션 컨텍스트

- `그림 1-5`는 하나의 웹 애플리케이션 내에 두 개의 스프링 서블릿이 존재하는 경우에 만들어지는 애플리케이션 컨텍스트와 그 관계를 보여준다.
  - 서블릿 A와 서블릿 B는 각각 자신의 전용 애플리케이션 컨텍스트를 갖는다.
    - 동시에 두 컨텍스트가 공유해서 사용하는 빈을 담아놓을 부모 컨텍스트를 만든다.
- `그림 1-6`처럼 일반적으로는 스프링의 애플리케이션 컨텍스트를 가지면서 프론트 컨트롤러 역할을 하는 서블릿은 하나만 만들어 사용한다.
  - `그림 1-6`은 여러 개의 자식 컨텍스트를 두고 공통적인 부모 컨텍스트로 뽑아내서 공유하는게 아닌데 왜 계층구조로 만들었을까?
    - 그 이유는 전체 애플리케이션에서 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분하기 위해서다.
- 스프링을 이용하는 웹 애플리케이션이라고 해서 반드시 스프링이 제공하는 웹 기술을 사용해야 하는 건 아니다.
  - 데이터 액세스 계층이나 서비스 계층은 스프링 기술을 사용하고 스프링 빈으로 만든다.
    - 하지만 웹을 담당하는 프레젠테이션 계층은 스프링 외의 기술을 사용하는 경우도 종종 있다.

- 스프링 서블릿을 사용하는 스프링의 웹 기술 외의 웹 기술
  - JSP나 스트럿츠, AJAX 엔진 등
  - 이런 곳에서는 어떻게 루트 애플리케이션 컨텍스트로 접근할 수 있나?
    - 서블릿 컨텍스트를 통해 루트 애플리케이션 컨텍스트에 접근할 수 있다.
      - `ServletContext`는 웹 애플리케이션마다 하나씩 만들어진다.
        - 서블릿의 런타임 환경정보를 담고 있다.
      - `HttpServletRequest`나 `HttpSession` 오브젝트를 갖고 있다면 간단히 `ServletContext`를 가져올 수 있다.

- 프레젠테이션 계층을 분리해서 계층구조로 애플리케이션 컨텍스트를 구성해두면 언제든 간단히 웹 기술을 확장하거나 변경, 조합해서 사용할 수 있다.

- 하나의 컨텍스트가 사용할 설정파일을 여러 개 등록
  - 성격이 다르거나 관리 주체가 달라지는 경우에 파일을 여러 개로 분리하면 유용할 때가 많다.



#### 웹 애플리케이션의 컨텍스트 구성 방법

- 서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층구조
  - 가장 많이 사용되는 기본적인 구성 방법
  - 스프링 웹 기술을 사용하는 경우 웹 관련 빈들은 서블릿 컨텍스트에 두고 나머지는 루트 애플리케이션 컨텍스트에 등록
- 루트 애플리케이션 컨텍스트 단일구조
  - 스프링 웹 기술을 사용하지 않고 서드파티 웹 프레임워크나 서비스 엔진만 사용해서 프레젠테이션 계층을 만든다면 스프링 서블릿을 둘 이유가 없다.
- 서블릿 컨텍스트 단일구조
  - 스프링 웹 기술을 사용하면서 스프링 외의 프레임워크나 서비스 엔진에서 스프링의 빈을 이용할 생각이 아니라면 루트 애플리케이션 컨텍스트를 생략할 수도 있다.
  - 이때는 서블릿 안에 만들어지는 애플리케이션 컨텍스트가 부모 컨텍스트를 갖지 않기 때문에 스스로 루트 컨텍스트가 된다.



#### 루트 애플리케이션 컨텍스트 등록

- 애플리케이션 레벨에 만들어지는 루트 웹 애플리케이션 컨텍스트를 등록하는 가장 간단한 방법은 서블릿의 이벤트 리스너를 이용하는 것이다.
  - `ServletContextListener`
    - 웹 애플리케이션의 시작과 종료 시 발생하는 이벤트를 처리하는 리스너
  - `ContextLoaderListener`
    - 웹 애플리케이션이 시작할 때 자동으로 루트 애플리케이션 컨텍스트를 만들고 초기화해준다.
      - 자동으로 만들어진 루트 애플리케이션 컨텍스트는 서블릿 컨텍스트에 등록된다.
    - 별다른 파라미터를 지정하지 않으면, 디폴트로 설정된 다음의 값이 적용된다.
      - 애플리케이션 컨텍스트 클래스
        - `XmlWebApplicationContext`
      - XML 설정파일 위치
        - `/WEB-INF/applicationContext.xml`



#### 서블릿 애플리케이션 컨텍스트 등록

- 스프링의 웹 기능을 지원하는 프론트 컨트롤러 서블릿은 `DispatcherServlet`이다.
  - 서블릿 이름을 다르게 지정해주면 하나의 웹 애플리케이션에 여러 개의 `DispatcherServlet`을 등록할 수도 있다.
  - 각 `DispatcherServlet`은 서블릿이 초기화 될 때 자신만의 컨텍스트를 생성하고 초기화한다.
    - 동시에 웹 애플리케이션 레벨에 등록된 루트 애플리케이션 컨텍스트를 찾아서 이를 자신의 부모 컨텍스트로 사용한다.



## 1.2 IoC/DI를 위한 빈 설정 메타정보 작성



### 1.2.1 빈 설정 메타정보

빈 설정 메타정보 항목

### 1.2.2 빈 등록 방법

XML: 《bean》 태그

XML: 네임스페이스와 전용 태그

자동인식을 이용한 빈 등록: 스테레오타입 애노테이션과 빈 스캐너

자바 코드에 의한 빈 등록: @Configuration 클래스의 @Bean 메소드

자바 코드에 의한 빈 등록: 일반 빈 클래스의 @Bean 메소드

빈 등록 메타정보 구성 전략

### 1.2.3 빈 의존관계 설정 방법

XML: 《property》, 《constructor-arg》

XML: 자동와이어링

XML: 네임스페이스와 전용 태그

애노테이션: @Resource

애노테이션: @Autowired/@Inject

@Autowired와 getBean(), 스프링 테스트

자바 코드에 의한 의존관계 설정

빈 의존관계 설정 전략

### 1.2.4 프로퍼티 값 설정 방법

메타정보 종류에 따른 값 설정 방법

PropertyEditor와 ConversionService

컬렉션

Null과 빈 문자열

프로퍼티 파일을 이용한 값 설정

### 1.2.5 컨테이너가 자동등록하는 빈

ApplicationContext, BeanFactory

ResourceLoader, ApplicationEventPublisher

systemProperties, systemEnvironment

## 1.3 프로토타입과 스코프


### 1.3.1 프로토타입 스코프

프로토타입 빈의 생명주기와 종속성

프로토타입 빈의 용도

DI와 DL

프로토타입 빈의 DL 전략

### 1.3.2 스코프

스코프의 종류

스코프 빈의 사용 방법

커스텀 스코프와 상태를 저장하는 빈 사용하기


## 1.4 기타 빈 설정 메타정보


### 1.4.1 빈 이름

XML 설정에서의 빈 식별자와 별칭

애노테이션에서의 빈 이름

### 1.4.2 빈 생명주기 메소드

초기화 메소드

제거 메소드

### 1.4.3 팩토리 빈과 팩토리 메소드


## 1.5 스프링 3.1의 Ioc 컨테이너와 DI

### 1.5.1 빈의 역할과 구분

빈의 종류

컨테이너 인프라 빈과 전용 태그

빈의 역할

### 1.5.2 컨테이너 인프라 빈을 위한 자바 코드 메타정보

IoC/DI 설정 방법의 발전

자바 코드를 이용한 컨테이너 인프라 빈 등록

### 1.5.3 웹 애플리케이션의 새로운 IoC 컨테이너 구성

### 1.5.4 런타임 환경 추상화와 프로파일

환경에 따른 빈 설정정보 변경 전략과 한계

런타임 환경과 프로파일

활성 프로파일 지정 방법

프로파일 활용 전략

### 1.5.5 프로퍼티 소스

프로퍼티

스프링에서 사용되는 프로퍼티의 종류

프로파일의 통합과 추상화

프로퍼티 소스의 사용

@PropertySource와 프로퍼티 파일

웹 환경에서 사용되는 프로퍼티 소스와 프로퍼티 소스 초기화 오브젝트

## 1.6 정리



