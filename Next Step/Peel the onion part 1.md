

## 2장 문자열 계산기 구현을 통한 테스트와 리팩토링



### 2.1 main() 메소드를 활용한 테스트의 문제점

- main() 메소드 하나에서 프로덕션 코드에 여러 메소드들 한번에 테스트
  - 테스트 클래스를 별도의 클래스로 분리 했지만 갈수록 테스트용 main 메소드의 복잡도는 증가할 것이다.
- 메소드 분리를하고 메인 메소드에서 호출
  - 이렇게 해도 main() 모든 기능을 한번에 테스트해야함.
    - 한 기능만 테스트하려면 테스트 안 할 메소드 호출하는 부분을 주석처리 해야함.
      - 역시 허접함. 
- 심지어 main() 메소드로 테스트하는 방식은 수동이다.
- 이러한 문제를 해결하기 위해 JUnit 등장



### 2.2 JUnit을 활용해 main() 메소드 문제점 극복

- 한 번에 메소드 하나에만 집중
- 결과 값을 눈이 아닌 프로그램을 통해 자동화
  - assertEquals()
- 테스트 코드 중복 제거
  - 개발자가 가져야 할 좋은 습관 중의 하나는 중복 코드를 제거하는 것
    - 중복 코드는 프로그래밍의 가장 큰 적 중의 하나
  - @Before
    - 테스트 메소드 간에 서로 영향을 미치지 않고 독립적으로 메소들르 실행하기 위해 쓰인다.
    - 각 테스트가 실행될 때마다 인스턴스가 매번 다시 생성되는 방식으로 동작한다.



### 2.3 문자열 계산기 요구사항 및 실습

- 요구사항 분리 및 각 단계별 힌트

```java
// 힌트 "//"와 "\n" 문자 사이에 커스텀 구분자를 지정할 수 있다.
Matcher m = Pattern.compile("//(.)\n(.*)").matcher(text);
if (m.find()) {
  	String customDelimeter = m.grout(1);
  	String[] tokens = m.group(2).split(customDelimeter);
}
```



- 추가 요구사항
  - 요구사항을 만족하는 코드를 구현했다고 개발이 끝난 건 아니다.
  - 소스코드를 구현했으면 반드시 리팩토링이 뒤따라야 한다.
    - 리팩토링
      - 중복을 제거
      - 읽기 좋은 코드를 구현하기 위해 구조를 변경
      - 소스코드의 가독성을 높이고 유지보수를 편하게 하기 위해 소스코드의 구조를 변경하는 것.
      - 리팩토링을 한다고 기능상의 결과가 변경되면 안된다.
    - 초보자를 위한 리팩토링 3가지 원칙
      - 메소드가 한 가지 책임만 가지도록 구현한다.
      - 인덴트(indent, 들여쓰기) 깊이를 1단계로 유지한다.
      - else를 사용하지 마라.



### 2.4 테스트와 리팩토링을 통한 문자열 계산기 구현

- 앞 챕터를 보면 요구사항이 단순해도 소스코드의 복잡도가 금방 증가한다.
  - 복잡도가 증가하면 새로운 요구사항을 추가 구현하기 힘들다.
  - 테스트가 째질 경우 디버징하기도 힘들다.
- 복잡도가 높은 요구사항을 구현할 때 높아지는 소스코드 복잡도는 우짤것인가
  - **복잡도를 낮출 수 있는 방법 중의 하나가 끊임없는 리팩토링을 통해 소스코드를 깔끔하게 구현하는 연습을 하는 것이다.**

- 요구사항을 작은 단위로 나누기
  - 복잡한 문제를 풀어가기 위해 첫 번째로 진행해야 하는 작업이 복잡한 문제를 작은 단위로 나눠 좀 더 쉬운 문제로 만드는 작업이다.

- 모든 단계의 끝은 리팩토링
  - 소스코드의 복잡도가 쉽게 증가하는 이유는 하나의 요구사항을 완료한 후 리팩토링을 하지 않은 상태에서 다음 단계로 넘어가기 때문이다.
    - 각 단계에서 다음 단계로 넘어가기 위한 작업의 끝은 내가 기대하는 결과를 확인했을 때가 아니라 결과를 확인한 후 리팩토링까지 완료했을 때이다.
  - 지금까지 개발 과정 "구현 - > 테스트를 통한 결과 확인"
    - 앞으로 "구현 - > 테스트를 통한 결과 확인 - > 리팩토링"
- 문자열 계산기 구현
  - private으로 분리한 메소드들 말고 public으로 공개하고 있는 add() 메소드가 얼마나 읽기 쉽고, 좋은지가 가장 중요하다. 
  - 세부 구현은 모두 private 메소드로 분리해 일단 관심사에서 제외
    - add() 메소드를 딱 보면 무슨 일을 하는지 전체 흐름이 쉽게 파악된다.

```java
public class StringCalculator {
  
  	public int add(String text) {
      	if (isBlank(text)) {
          	return 0;
        }
      	
      	return sum(toInts(split(text)));
    }
  
  	private boolean isBlank(String text) {
      	return text == null || text.isEmpty();
    }
  
  	private String[] split(String text) {
      	return text.split(",");
    }
  
  	private int[] toInts(String[] values) {
      	int[] numbers = new int[values.length];
      	for (int i = 0; i < values.length; i++) {
          	numbers[i] = Integer.parseInt(values[i]);
        }
      	return numbers;
    }
  
  	private int sum(int[] numbers) {
      	int sum = 0;
      	for (int number : numbers) {
          	sum += number;
        }
    }
  
}
```



### 2.5 추가 학습 자료

- 테스트 주도 개발(Test Driven Development, 이하 TDD)과 리팩토링
- 정규 표현식
  - 손에 잡히는 정규 표현식
  - [온라인 상에서 연습할 수 있는 곳](https://regexr.com/)



## 3장 개발 환경 구축 및 웹 서버 실습 요구사항

- 새로운 무엇인가를 학습할 때 내가 이해한 수준까지 직접 라이브러리 또는 프레임워크를 구현해봄으로써 학습에 대한 깊이를 더해가는 방식으로 학습
  - 직접 구현해 봄으로써 자신이 이해하고 있는 부분과 모르는 부분을 명확히 알 수 있으며, 애플리케이션이 어떻게 동작하는지에 대해 깊이 있게 이해할 수 있는 계기가 된다.



### 3.1 서비스 요구사항



### 3.2 로컬 개발 환경 구축



### 3.3 원격 서버에 배포

- 애자일
  - 소프트웨어 개발 방법론
    - 짧은 주기의 개발 단위를 자주 반복해서 하나의 큰 소프트웨어를 완성해 나가는 방법론
  - 애자일 프로세스는 현 시점에 가장 가치가 있는, 동작하는 소프트웨어를 만드는 것을 원칙으로 하고 있다.
- 학습을 애자일하게 접근하기
  - 각 주제에 대한 깊이는 깊지 않을 수 있지만 프론트엔드부터 백엔드까지 기능을 구현한 후 개발 서버(또는 실 서버)에 배포하는 경험까지를 한 반복주기로 생각하고 학습
    - 원격서버에 직접 배포하는 경험을 반복함으로써 터미널 환경에서 작업하는 것에 익숙해지도록 해보자. 

- 원격 서버에 배포 힌트
  - 계정 추가 및 sudo 권한 할당
  - 각 계정별 UTF-8 인코딩 설정해 한글 이슈 해결 
  - JDK, 메이븐 설치
  - Git 설치, clone 및 빌드
  - 방화벽 설정
  - 소스코드 재배포



### 3.4 웹 서버 실습

- 실습 환경 세팅 및 소스코드 분석
  - 소스코드 분석
    - WebServer 클래스
      - 웹 서버를 시작하고, 사용자의 요청이 있을 때까지 대기 상태에 있다가 사용자 요청이 발생하는 순간 클라이언트와 연결을 담당하는 Socket을 RequestHandler에 전달
        - 새로운 스레드를 실행하는 방식으로 멀티스레드 프로그래밍을 지원
          - 쓰레드를 생성하는 방법
            - Thread를 상속하는 클래스의 정의
            - 인스턴스 생성
            - start 메소드 호출
    - `java.net.ServerSocket` 클래스
      - 사용자 요청이 발생할 때까지 대기 상태에 있도록 ㅈ원하는 역할
    - RequestHandler 클래스
      - `Thread`를 상속하고 있으며, 사용자의 요청에 대한 처리와 응답에 대한 처리를 담당하는 가장 중심이 되는 클래스
  - 프로그래밍을 할 때 좋은 습관 중의 하나는 프로그래밍 실행 중 발생하는 로그 메시지를 주의 깊게 살펴보는 것이다.



새로운 쓰레드 생성하지 말고 쓰레드풀 사용하게 변경 해볼까나 

마무리 하고 커밋



### 3.5 추가 학습 자료

- Git과 GitHub
- 빌드 도구 메이븐
- 디버깅을 위한 로깅(logging)
  - 자바 진영에서 많이 사용하는 로깅 라이브러리는 Logback이다.
  - SLF4J라는 라이브러리를 활용해 로깅 API에 대한 창구를 일원화
    - 자바 소스코드는 SLF4J 라이브러리를 사용해 디버깅 메시지를 남긴다.
      - 실제 디버깅 메시지 출력은 구현체인 Log4J, Logback 등 이 담당하는 방식
    - 추후 Logback 보다 더 좋은 로깅 라이브러리가 나온다면?
      - 소스코드는 수정할 필요없이 구현체만 바꿔주면 된다.  



## 4장 HTTP 웹 서버 구현을 통해 HTTP 이해하기



### 4.1 동영상을 활용한 HTTP 웹 서버 실습



### 4.2 HTTP 웹 서버 구현

- 실습
  - https://github.com/slipp/web-application-server



### 4.3 추가 학습 자료

- HTTP

  - [HTTP (HyperText Transfer Protocol)](https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html)

- 네트워크



## 5장 웹 서버 리팩토링, 서블릿 컨테이너와 서블릿의 관계



### 5.1 HTTP 웹 서버 리팩토링 실습



### 5.2 웹 서버 리팩토링 구현 및 설명

- HttpRequest, HttpResponse 별도의 클래스로 분리 

- 별도에 클래스로 분리한 부분을 바로 RequestHandler에 적용하지 않는다.

- 테스트 코드를 만들어서 테스트가 끝나면 적용
  - 적용하고 전체 테스트 돌려볼 수 있으면 좋은데
    - 스프링이었으면 Acceptance test를 만들어 돌려보면 될텐데

- enum으로 빼는 부분

- 다형성을 활용해서 if문 걷어내기



### 5.3 서블릿 컨테이너, 서블릿/JSP를 활용한 문제 해결

- 서블릿
  - 서블릿은 앞에서 구현한 웹서버 Controller, HttpRequest, HttpResponse를 추상화해 인터페이스로 정의해 놓은 표준이다.
  - HTTP의 클라이언트 요청과 응답에 대한 표준을 정해 높은 것을 서블릿이라 생각하면 된다.
- 서블릿은 앞에서 구현했던 Controller와 정확히 같은 역할을 하며, 똑같은 방식으로 동작한다.
  - doGet() 메소드의 인자로 전달하는 HttpServletRequest, HttpServletResponse는 앞에서 구현한 HttpRequest, HttpResponse와 같다.
  - Controller 인터페이스는 서블릿의 Servlet 인터페이스, AbstractController는 HttpServlet과 같다.
- 서블릿 컨테이너가 시작하고 종료할 때의 과정
  - 서블릿 컨테이너 시작
  - 클래스패스에 있는 Servlet 인터페이스를 구현하는 서블릿 클래스를 찾음
  - @WebServlet 설정을 통해 요청 URL과 서블릿 매핑
  - 서블릿 인스턴스 생성
  - init() 메소드를 호출해 초기화
    - 서블릿 인터페이스 참고(서블릿의 생명주기)
      - service()
      - destroy()
- 자바 진영에서 웹 애플리케이션을 개발하면 컨테이너라는 용어를 접하게 된다. 
  - 각 컨테이너마다 다른 기능을 지원하지만 기본적으로 컨테이너는 생명주기를 관리하는 기능을 제공한다.
  - 스프링 프레임워크는 빈의 생명주기를 관리하는 기능을 제공한다.
  - 새로운 컨테이너를 학습할 기회가 있다면 서블릿 생명주기와 같은 방식으로 구현되어 있는지 확인해봐라.
    - 대부분 같은 방식으로 동작하기 때문에 새로운 컨테이너라도 좀 더 빠르게 학습할 수 있다.



### 5.4 추가 학습 자료

- 객체지향 설계와 개발
- 서블릿 & JSP, 웹 애플리케이션 서버
- 템플릿 엔진



## 6장 서블릿/JSP를 활용해 동적인 웹 애플리케이션 개발하기



### 6.1 서블릿/JSP로 회원관리 기능 다시 개발하기

- JSP
  - Java Server Page
  - 서블릿의 한계를 극복하기 위해 등장
  - 정적인 HTML은 그대로 두고 동적으로 변경되는 부분만 JSP 구문을 활용해 프로그래밍으로 구현
    - 스크립틀릿이라고 하는 `<% %>` 내에 자바 구문을 그대로 사용할 수 있다.
      - 많은 로직이 JSP에 자바 코드로 구현되면 JSP 유지보수가 힘들어 진다.
      - JSTL과 EL을 활용하면 JSP에서 자바 구문을 완전히 제거할 수 있다.

- 실습
  - https://github.com/slipp/jwp-basic



### 6.2 세션(HttpSession) 요구사항 및 실습



### 6.3 세션(HttpSession) 구현



### 6.4 MVC 프레임워크 요구사항 1단계



### 6.5 MVC 프레임워크 구현 1단계



### 6.6 쉘 스크립트를 활용한 배포 자동화



### 6.7 추가 학습 자료

















## 7장 DB를 활용해 데이터를 영구적으로 저장하기





### 7.1 회원 데이터를 DB에 저장하기 실습

### 7.2 DAO 리팩토링 실습

### 7.3 동영상을 활용한 DAO 리팩토링 실습

### 7.4 DAO 리팩토링 및 설명

### 7.5 추가 학습 자료



## 8장 AJAX를 활용해 새로고침 없이 데이터 갱신하기

### 8.1 질문/답변 게시판 구현

### 8.2 AJAX 활용해 답변 추가, 삭제 실습

### 8.3 MVC 프레임워크 요구사항 2단계

### 8.4 MVC 프레임워크 구현 2단계

### 8.5 추가 학습 자료