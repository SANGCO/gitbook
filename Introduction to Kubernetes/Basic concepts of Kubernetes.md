

## 4장. 쿠버네티스 아키텍처



### 4.1 쿠버네티스 클러스터의 전체 구조

- `그림 4-1` 쿠버네티스 클러스터의 기본 구성 참고
  - 마스터는 보통 고가용성을 만족하고자 서버 3대 정도 구성해서 운영
- `그림 4-2` 마스터와 노드의 구성과 통신 구조 참고



### 4.2 쿠버네티스의 주요 컴포넌트

- 쿠버네티스는 근본적으로 클러스터를 관리한다.
  - 클러스터는 단일 컴퓨터가 아니라 여러대 컴퓨터를 하나의 묶음으로 다루는 것을 뜻한다.



#### 4.2.1 마스터용 컴포넌트

- 마스터용 컴포넌트들은 실제 클러스터 전체를 관리한다.



##### etcd

- etcd는 코어OS에서 개발한 고가용성을 제공하는 키-값 저장소이다.
  - 분산 시스템에서 노드 사이의 상태를 공유하는 합의 알고리즘 중 하나인 raft 알고리즘을 구현한 것이다.
  - 쿠버네티스에서는 필요한 모든 데이터를 저장하는 **데이터베이스 역할**을 한다.
- 보통 etcd 자체를 클러스터링한 후 **여러 개 마스터 서버에 분산**해서 실행해 데이터의 안정성을 보장하도록 구성
  - 주기적으로 etcd에 있는 데이터를 백업할 것을 권한다.
  - 클러스터링은 여러 대 컴퓨터를 연결해 시스템 하나처럼 구성하는 것이다.
  - 여러 개의 마스터에 있는 etcd들은 다 클러스터링 되어있는건가?



##### kube-apiserver

- kube-apiserver는 쿠버네티스 클러스터의 API를 사용할 수 있도록 하는 컴포넌트이다.
  - 클러스터로 온 요청이 유효한지 검증한다.
    - 권한 체크
- 쿠버네티스는 마이크로서비스 아키텍처이므로 서로 분리된 컴포넌트 여러 개로 구성되어 있다.
  - 쿠버네티스에 보내는 모든 요청은 kube-apiserver를 이용해서 다른 컴포넌트로 전달한다.

- 서버 여러 대에 여러 개 kube-apiserver를 실행해 시용할 수 있다.



##### kube-scheduler

- kube-scheduler는 현재 클러스터 안에서 자원 할당이 가능한 노드 중 알맞은 노드를 선택해서 새롭게 만든 파드를 실행한다(그래서 스케줄러이다).
  - 파드는 처음 실행할 때 여러 가지 조건을 설정하며, kube-scheduler가 조건에 맞는 노드를 찾는다.



##### kube-controller-manager

- 쿠버네티스는 파드들을 관리하는 컨트롤러가 있다.
- kube-controller-manager는 컨트롤러 각각을 실행하는 컴포넌트이다.
  - 클러스터 안에서 새로운 컨트롤러를 사용할 때는 컨트롤러에 해당하는 구조체를 만든다.
    - 구조체? C언어에?



##### cloud-controller-manager

- 쿠버네티스의 컨트롤러들을 클라우드 서비스와 연결해 관리하는 컴포넌트
  - 관련 컴포넌트의 소스 코드는 각 클라우드 서비스에서 직접 관리한다.
- 보통 네 가지 컨트롤러 컴포넌트를 관리한다.
  - 노드 컨트롤러(Node Controller)
    - 클라우드 서비스 안에서 노드를 관리하는 데 사용한다.
  - 라우트 컨트롤러(Route Controller)
    - 각 클라우드 서비스 안의 네트워크 라우팅을 관리하는 데 사용한다.
  - 서비스 컨트롤러(Service Controller)
    - 각 클라우드 서비스에서 제공하는 로드밸런서를 생성, 갱신, 삭제하는 데 사용한다.
  - 볼륨 컨트롤러(Volume Controller)
    - 클라우드 서비스에서 생성한 볼륨을 노드에 연결하거나 마운트하는 등에 사용한다.



#### 4.2.2 노드용 컴포넌트

- 노드용 컴포넌트는 쿠버네티스 실행 환경을 관리한다.
  - 대표적으로 각 노드의 파드 실행을 관리하는 것이 있다.



##### kubelet

- kubelet은 클러스터 안 모든 노드에서 실행되는 에이전트이다.
  - 파드 컨테이너들의 실행을 직접 관리한다.
- kubelet은 파드스펙이라는 조건이 담긴 설정을 전달받아서 컨테이너를 실행하고 컨테이너가 정상적으로 실행되는지 헬스 체크를 진행한다.
  - 노드안에 있는 컨테이너라도 쿠버네티스가 만들지 않은 컨테이너는 관리하지 않는다.



##### kube-proxy

- 쿠버네티스는 클러스터 안에 별도의 가상 네트워크를 설정하고 관리한다.
  - kube-proxy는 이런 가상 네트워크의 동작을 관리하는 컴포넌트이다.



##### 컨테이너 런타임

- 컨테이너 런타임은 실제로 컨테이너를 실행시킨다.
  - 가장 많이 알려진 런타임으로는 도커가 있고 containerd, runc 같은 런타임도 지원한다.



#### 4.2.3 애드온

애드온은 클러스터 안에서 필요한 기능을 실행하는 파드이다.



##### 네트워킹 애드온



##### DNS 애드온



##### 대시보드 애드온



##### 컨테이너 자원 모니터링



##### 클러스터 로깅





### 4.3 오브젝트와 컨트롤러

- 쿠버네티스는 크게 오브젝트와 오브젝트를 관리하는 컨트롤러로 나눈다.
  - 오브젝트
    - 파드, 서비스, 볼륨, 네임스페이스 등이 있다.
  - 컨트롤러
    - 레플리카세트, 디플로이먼트, 스테이트풀세트, 데몬세트, 잡 등이 있다.
- 사용자는 템플릿 등으로 쿠버네티스에 자원의 '바라는 상태'를 정의하고 컨트롤러는 바라는 상태와 현재 상태가 일치하도록 오브젝트들을 생성/삭제한다.



#### 4.3.1 네임스페이스

- 네임스페이스는 쿠버네티스 클러스터 하나를 여러 개 논리적인 단위로 나눠서 사용한다.
  - 용도에 따라 실행해야 하는 앱을 구분
  - 특정 네임스페이스의 사용량을 제한
- 현재 생성되어 있는 네임스페이스 확인
  - `kubectl get namespaces`
- 쿠버네티스가 기본으로 생성하는 네임스페이스
  - default
  - kube-system
  - kube-public
  - kube-node-lease



#### 4.3.2 템플릿

- 쿠버네티스 클러스터의 오브젝트나 컨트롤러가 어떤 상태여야 하는지를 적용할 때는 YAML 형식의 템플릿을 사용한다.
  - 템플릿의 내용을 표현하는 YAML은 JSON과 비교했을 때 간결하다.
    - 주석도 지원하므로 가독성이 좋다.
    - 들여쓰기에 따라 구조가 바뀌므로 들여쓰기에 주의 해야 한다.

- YAML
  - YAML은 세 가지 기초 요소로 표현한다.
    - Scalars(strings/numbers)
    - Sequences(arrays/lists)
    - Mappings(hashes/dictionaries)
  - 주석은 '#'로 시작하며, 여러 줄 주석은 지원하지 않는다.
  - '---'은 성격이 다른 YAML 형식의 문서 여러 개가 있을 때 구분자로 사용



## 5장. 파드

- 쿠버네티스에서 컨테이너를 관리하는 기본 단위인 파드



### 5.1 파드 개념



### 5.2 파드 사용하기



### 5.3 파드 생명 주기

- 파드 생명 주기
  - Pending
  - Running
  - Succeeded
  - Failed
  - Unknown
- Type이 나타내는 정보
  - Initialized
  - Ready
  - ContainersReady
  - PodScheduled
  - Unschedulable



### 5.4 kubelet으로 컨테이너 진단하기



### 5.5 초기화 컨테이너



### 5.6 파드 인프라 컨테이너



### 5.7 스태틱 파드



### 5.8 파드에 CPU와 메모리 자원 할당



### 5.9 파드에 환경 변수 설정하기



### 5.10 파드 환경 설정 내용 적용하기



### 5.11 파드 구성 패턴



#### 5.11.1 사이드카 패턴



#### 5.11.2 앰배서더 패턴



#### 5.11.3 어댑터 패턴





## 6장. 컨트롤러

- 컨트롤러는 파드들을 관리하는 역할을 한다.
  - 다양한 목적에 맞게 사용할 수 있는 컨트롤러가 있다는 것이 쿠버네티스의 큰 장점이기도 하다.



6.1 레플리케이션 컨트롤러
6.2 레플리카세트
6.2.1 레플리카세트 사용하기
6.2.2 레플리카세트와 파드의 연관 관계
6.3 디플로이먼트
6.3.1 디플로이먼트 사용하기
6.3.2 디플로이먼트 롤백하기
6.3.3 파드 개수 조정하기
6.3.4 디플로이먼트 배포 정지, 배포 재개, 재시작하기
6.3.5 디플로이먼트 상태
6.4 데몬세트
6.4.1 데몬세트 사용하기
6.4.2 데몬세트의 파드 업데이트 방법 변경하기
6.5 스테이트풀세트
6.5.1 스테이트풀세트 사용하기
6.5.2 파드를 순서 없이 실행하거나 종료하기
6.5.3 스테이트풀세트로 파드 업데이트하기
6.6 잡
6.6.1 잡 사용하기
6.6.2 잡 병렬성 관리
6.6.3 잡의 종류
6.6.4 비정상적으로 실행 종료된 파드 관리하기
6.6.5 잡 종료와 정리
6.6.6 잡 패턴
6.7 크론잡
6.7.1 크론잡 사용하기
6.7.2 크론잡 설정





## 7장. 서비스

- 서비스는 여러 개 파드에 접근할 수 있는 IP 하나를 제공한다.
  - 다양한 기능을 제공하지만 본질적으로 로드밸런서 역할이다.







7.1 서비스의 개념
7.2 서비스 타입
7.3 서비스 사용하기
7.3.1 ClusterIP 타입 서비스 사용하기
7.3.2 NodePort 타입 서비스 사용하기
7.3.3 LoadBalancer 타입 서비스 사용하기
7.3.4 ExternalName 타입 서비스 사용하기
7.4 헤드리스 서비스
7.5 kube-proxy
7.5.1 userspace 모드
7.5.2 iptables 모드
7.5.3 IPVS 모드



## 8장. 인그레스

- 인그레스는 주로 클러스터 외부에서 안에 있는 파드에 접근할 때 사용하는 방법이다.
  - 서비스와의 차이점은 주로 L7 영역의 통신을 담당해서 처리한다는 것이다.



8.1 인그레스의 개념
8.2 ingress-nginx 컨트롤러
8.3 인그레스 SSL 설정하기
8.4 무중단 배포를 할 때 주의할 점
8.4.1 maxSurge와 maxUnavailable 필드 설정
8.4.2 파드가 readinessProbe를 지원하는지 확인
8.4.3 쿠버네티스와 컨테이너 안에 그레이스풀 종료 설정
8.5 무중단 배포 테스트



## 9장. 레이블과 애너테이션

- 레이블과 애너테이션은 쿠버네티스에서 자원들의 메타데이터를 관리하는 데 사용한다.
  - 레이블은 셀렉터와 함께 특정 레이블이 있는 자원들을 선택할 때 주로 사용한다.
  - 애너테이션은 주석 성격의 메타데이터를 기록하는 데 사용한다.
- 레이블과 애너테이션은 상황에 맞게 구분해서 사용한다.
  - 레이블은 쿠버네티스 클러스터 안에서 사용자가 오브젝트를 생성할 때 해당 오브젝트를 구분하는 용도이다.
    - 사용자가 임의로 원하는 값을 지정해서 사용한다.
  - 애너테이션은 레이블처럼 사용자가 원하는 값을 설정하기보다 쿠버네티스 시스템에서 필요한 정보들을 표시하는 데 사용한다.



9.1 레이블
9.2 애너테이션
9.3 레이블을 이용한 카나리 배포



## 10장. 컨피그맵

- 컨피그맵은 컨테이너에 필요한 환경 설정을 컨테이너와 분리해서 제공하는 기능이다.



10.1 컨피그맵 사용하기
10.2 컨피그맵 설정 중 일부만 불러와서 사용하기
10.3 컨피그맵 설정 전체를 한꺼번에 불러와서 사용하기
10.4 컨피그맵을 볼륨에 불러와서 사용하기





## 11장. 시크릿

- 시크릿은 비밀번호, OAuth 토큰, SSH 키 같은 민감한 정보들을 저장하는 용도로 사용한다.
  - 이런 정보들은 컨테이너 안에 저장하지 않고 별도로 보관했다가 실제 파드를 실행할 때의 템플릿으로 컨테이너에 제공한다.



11.1 시크릿 만들기
11.1.1 명령으로 시크릿 만들기
11.1.2 템플릿으로 시크릿 만들기
11.2 시크릿 사용하기
11.2.1 파드의 환경 변수로 시크릿 사용하기
11.2.2 볼륨 형식으로 파드에 시크릿 제공하기
11.2.3 프라이빗 컨테이너 이미지를 가져올 때 시크릿 사용하기
11.2.4 시크릿으로 TLS 인증서를 저장해 사용하기
11.3 시크릿 데이터 용량 제한